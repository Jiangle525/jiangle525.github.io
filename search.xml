<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux_vim命令</title>
      <link href="/2020/07/17/Linux_vim%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/07/17/Linux_vim%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建个人博客</title>
      <link href="/2020/07/17/Hexo_hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/07/17/Hexo_hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><blockquote><p>hexo安装好之后，就可以开始搭建属于自己的博客了。如果没有安装hexo，参考文章：<a href="/2020/04/04/Hexo_hexo安装教程/">hexo安装教程</a></p></blockquote><h1 id="1-初始化项目"><a href="#1-初始化项目" class="headerlink" title="1. 初始化项目"></a>1. 初始化项目</h1><ul><li><p>为你的博客创建一个新的文件夹，该文件夹未来就是你博客放代码的地方，随便放哪都行。比如我的是：<code>D:\MyBolg</code>，创建命令如下：</p><pre><code>hexo init /d/mybolg            # Windows命令行不区分大小写</code></pre></li><li><p>初始化后，目录结构如下：</p><pre><code class="bash">.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes</code></pre><ol><li><p>_config.yml是总配置文件，里面可以修改很多东西，建议里面的所有设置都可以看看，根据里面的注释进行响应的改动，这里就不展开了。</p></li><li><p>themes目录下会自动生成一个默认的主题<code>landscape</code>，并且在source/_post目录下也自动生成了第一篇博客<code>hello-world</code></p></li></ol></li><li><p>启动本地预览服务命令：<code>hexo s</code>，然后在浏览器访问<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000</a>即可看到默认的博客内容</p><p><strong>小妙招：可以使用<code>hexo -h</code>查看hexo命令格式以及选项</strong></p></li></ul><h1 id="2-更换主题"><a href="#2-更换主题" class="headerlink" title="2. 更换主题"></a>2. 更换主题</h1><h2 id="2-1-下载地址"><a href="#2-1-下载地址" class="headerlink" title="2.1 下载地址"></a>2.1 下载地址</h2><ul><li>hexo主题下载地址：<a href="https://hexo.io/themes/#simple" target="_blank" rel="noopener"><a href="https://hexo.io/themes/#simple" target="_blank" rel="noopener">https://hexo.io/themes/#simple</a></a></li><li>选择一个你喜欢的主题，将其下载并保存到<code>themes/</code>目录下。比如下载的主题为xxx，其相对于博客主目录的路径为<code>themes/xxx</code></li></ul><h2 id="2-2-配置主题"><a href="#2-2-配置主题" class="headerlink" title="2.2 配置主题"></a>2.2 配置主题</h2><ul><li>将<code>_config.yml</code>中<code>theme: landscape</code>修改为<code>theme: xxx</code>，执行<code>hexo g</code>重新生成一下，g就表示generate选项。</li><li>如果出现一些莫名其妙的问题，可以先执行<code>hexo clean</code>来清理一下public的内容，然后再来重新生成和发布。</li></ul><h1 id="3-上传到github"><a href="#3-上传到github" class="headerlink" title="3. 上传到github"></a>3. 上传到github</h1><ul><li><p>修改_config.yml文件的deploy，直接修改一下yourname部分就可以了</p><pre><code class="bash">deploy:  type: git  repository: git@github.com:yourname/yourname.github.io.git  branch: master</code></pre></li><li><p>使用hexo deploy将本次改动的代码全部提交到github上</p></li></ul><h1 id="4-技巧"><a href="#4-技巧" class="headerlink" title="4. 技巧"></a>4. 技巧</h1><h2 id="4-1-快捷命令"><a href="#4-1-快捷命令" class="headerlink" title="4.1 快捷命令"></a>4.1 快捷命令</h2><ul><li><p>其实就通过 alias，触发一些命令的集合<br>在 <code>~/.bashrc</code> 文件中添加</p><pre><code>alias hs=&#39;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&#39;  #启动本地服务alias hd=&#39;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d&#39;  #部署博客</code></pre><p>甚至你也可以加入备份文章的命令，可以自由发挥。</p></li></ul><h2 id="4-2-博客备份（快捷命令升级版）"><a href="#4-2-博客备份（快捷命令升级版）" class="headerlink" title="4.2 博客备份（快捷命令升级版）"></a>4.2 博客备份（快捷命令升级版）</h2><ul><li>为了保证我们写的文章不丢失、快速迁移博客，都需要备份我们的 blog</li></ul><ol><li><p>博客根目录，执行 <code>git init</code> 创建 git 仓库</p></li><li><p>在 github（或其他托管平台、自建远程仓库等） 创建仓库并和本地仓库建立联系</p></li><li><p>在<code>~/.bashrc</code>文件中添加，使用<code>vim</code>命令，详情参见<a href="/2020/07/17/Linux_vim命令/">vim命令用法</a></p><pre><code>alias hs=&#39;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&#39;alias hd=&#39;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; git add . &amp;&amp; git commit -m &quot;update&quot; &amp;&amp; git push -f&#39;</code></pre></li></ol><ul><li>这样，我们在执行<code>hs</code>启动本地预览服务，当执行 <code>hd</code> 进行部署时，就一同将博客进行备份了</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux日常学习——pwd命令</title>
      <link href="/2020/06/12/Linux_pwd%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/06/12/Linux_pwd%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><blockquote><p>Linux中用 <code>pwd</code> 命令来查看”当前工作目录“的完整路径。 简单得说，每当你在终端进行操作时，你都会有一个当前工作目录。在不太确定当前位置时，就会使用<code>pwd</code>来判定当前目录在文件系统内的确切位置。</p></blockquote><h1 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2. 命令格式"></a>2. 命令格式</h1><pre><code class="bash">$ pwd [选项]</code></pre><h1 id="3-实用实例"><a href="#3-实用实例" class="headerlink" title="3. 实用实例"></a>3. 实用实例</h1><p><strong>例一：用 pwd 命令查看当前工作目录的完整路径</strong></p><pre><code class="bash">$ pwd/home/jiangle</code></pre><p><strong>例二：目录连接链接时，pwd -P 显示出实际路径，而非使用连接（link）路径；pwd显示的是连接路径</strong></p><pre><code class="bash">#目录为链接时，输出链接路径$ pwd -L#目录为链接时，输出物理路径$ pwd -P/home/jiangle</code></pre><p><strong>例三：当前目录被删除了，而pwd命令仍然显示那个目录</strong></p><pre><code class="bash">$ cd /opt/soft$ rm ../soft -rf$ pwd/opt/soft$ cd /bin/pwd/bin/pwd: couldnt find directory entry in “..” with matching i-node/home/jiangle</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux日常学习——cd命令</title>
      <link href="/2020/06/12/Linux_cd%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/06/12/Linux_cd%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><blockquote><p><code>cd</code> 命令是Linux中最基本的命令语句，其他的命令语句要进行操作，都是建立在使用 <code>cd</code> 命令上的。</p></blockquote><h1 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2. 命令格式"></a>2. 命令格式</h1><pre><code>$ cd [目录名]</code></pre><h1 id="3-范例"><a href="#3-范例" class="headerlink" title="3. 范例"></a>3. 范例</h1><p><strong>例一：进入系统根目录</strong></p><pre><code>$ cd /</code></pre><p><strong>例二：进入父级目录</strong></p><pre><code>$ cd ..$ cd ..//</code></pre><p><strong>例三：使用 cd 命令进入当前用户主目录</strong></p><pre><code>$ cd$ cd ~</code></pre><p><strong>例四：跳转到指定目录</strong></p><pre><code>$ cd /usr/bin</code></pre><p><strong>例五：返回进入此目录之前所在的目录</strong></p><pre><code>$ cd -</code></pre><p><strong>例六：把上个命令的参数作为cd参数使用</strong></p><pre><code>$ cd !$</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux日常学习——ls命令</title>
      <link href="/2020/06/12/Linux_ls%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/06/12/Linux_ls%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><blockquote><p><code>ls</code>是Linux下非常常用的命令，它是list的缩写，用于显示指定工作目录下的内容，以及文件和目录的权限等等。</p></blockquote><h1 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2. 命令格式"></a>2. 命令格式</h1><pre><code class="bash">$ ls \[选项] [目录名]</code></pre><h1 id="3-参数介绍"><a href="#3-参数介绍" class="headerlink" title="3. 参数介绍"></a>3. 参数介绍</h1><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-a,–all</td><td>列出目录下的所有文件，包括以 . 开头的隐含文件</td></tr><tr><td>-A</td><td>同-a，但不列出“.”(表示当前目录)和“..”(表示当前目录的父目录)。</td></tr><tr><td>-l</td><td>除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。</td></tr><tr><td>-t</td><td>将文件依建立时间之先后次序列出</td></tr><tr><td>-r, –reverse</td><td>依相反次序排列(原定依英文字母次序)</td></tr><tr><td>-R, –recursive</td><td>同时列出所有子目录层</td></tr><tr><td>-s,–size</td><td>以块大小为单位列出所有文件的大小</td></tr><tr><td>-S</td><td>根据文件大小排序</td></tr><tr><td>-F</td><td>在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“</td></tr></tbody></table><h1 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h1><ol><li>列出根目录（/）下的所有目录：</li></ol><pre><code class="bash"># ls /bin               dev   lib         media  net   root     srv  upload  wwwboot              etc   lib64       misc   opt   sbin     sys  usrhome  lost+found  mnt    proc  selinux  tmp  var</code></pre><ol start="2"><li>列出目前工作目录下所有名称是 s 开头的文件，越新的排越后面 :</li></ol><pre><code class="bash">ls -ltr s*</code></pre><ol start="3"><li>将 /bin 目录以下所有目录及文件详细资料列出 :</li></ol><pre><code class="bash">ls -lR /bin</code></pre><ol start="4"><li>列出目前工作目录下所有文件及目录；目录于名称后加 “/“, 可执行档于名称后加 “*” :</li></ol><pre><code class="bash">ls -AF</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux日常学习——awk命令</title>
      <link href="/2020/06/12/Linux_awk%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/06/12/Linux_awk%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><ul><li><code>awk</code>是一种编程语言（解释性语言，不需要编译），用于<strong>数据截取和报告的工具</strong></li><li><code>awk</code>自动搜索输入的文件，并把每个输入行切分成多个字段（字段：根据分隔符分割成的单元）</li><li>擅长<strong>处理数据库和表型数据</strong>。适合编写短小一次性程序</li><li><code>centos</code>默认的<code>awk</code>使用的是<code>gawk</code>，系统将<code>awk</code>通过软链接来指向<code>gawk</code></li><li>可以使用新的内置函数和变量</li><li>在缺省的情况下，它使用扩展的正则表达式</li><li><code>awk</code>不需要声明变量的数据类型，它内置字符串类型和数值类型</li></ul><h1 id="二、命令格式"><a href="#二、命令格式" class="headerlink" title="二、命令格式"></a>二、命令格式</h1><pre><code>awk [OPTIONS] [--] program filename_list</code></pre><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-f program -file</td><td>指定包含了awk命令的文件，不是从命令行参数中去读取 可以通过-f选项指定多个包含awk命令文件</td></tr><tr><td>-F ‘fs’ –field -separator</td><td>指定分隔符即为定义FS变量对应的值</td></tr><tr><td>-v var=val</td><td>在程序开始之前，将val这个值赋给var这个变量</td></tr><tr><td>-d[file]</td><td>将全局变量的类型和最终值排序，并将排序好后的结果打印输出到文件中</td></tr><tr><td>-V</td><td>显示awk的版本</td></tr></tbody></table><h1 id="三、使用方法及范例"><a href="#三、使用方法及范例" class="headerlink" title="三、使用方法及范例"></a>三、使用方法及范例</h1><h2 id="3-1-awk的核心"><a href="#3-1-awk的核心" class="headerlink" title="3.1 awk的核心"></a>3.1 awk的核心</h2><ul><li><strong>PROGRAM——‘pattern{action}’</strong></li></ul><h2 id="3-2-关于pattern-action-的说明："><a href="#3-2-关于pattern-action-的说明：" class="headerlink" title="3.2 关于pattern { action }的说明："></a>3.2 关于pattern { action }的说明：</h2><ul><li><code>pattern</code>与<code>action</code>并非同时存在，可以省略其中一个</li><li>如果<code>action</code>被省略，默认动作是将每个匹配的行输出</li><li>如果<code>pattern</code>被省略，对于每行都会执行动作</li></ul><h3 id="awk基本操作流程："><a href="#awk基本操作流程：" class="headerlink" title="awk基本操作流程："></a>awk基本操作流程：</h3><ol><li>从输入流中读取一行内容，然后使用<code>pattern{action}</code>去处理</li><li>对读取的行进行扫描搜索，搜索行中是否有内容被pattern匹配</li><li>如果行被<code>pattern</code>匹配成功，则执行动作<code>{action}</code>；如果行中内容不被<code>pattern</code>匹配，则不执行</li><li>继续从输入流中读取新的一行，重复上述几个步骤</li></ol><h4 id="例一：简单理解awk"><a href="#例一：简单理解awk" class="headerlink" title="例一：简单理解awk"></a>例一：简单理解awk</h4><p>问题描述：</p><ul><li><code>file1</code>文件第一列为员工名字，第二列为时薪，第三列为工作时长</li><li>打印输出员工的名字、时薪和工作时长</li></ul><p>执行命令：</p><pre><code class="bash">[root@CentOS7 commands]# cat file1Sam    50    8Jiangle    55    9Tom    40    6Tim    60    9[root@CentOS7 commands]# awk &#39;{print $1,$2,$3}&#39; file1Sam    50    8Jiangle    55    9Tom    40    6Tim    60    9</code></pre><p><strong>说明：</strong></p><ul><li><code>awk</code>命令后面的程序用<strong>单引号</strong>引起来，单引号后面的部分为输入文件</li><li>单引号中包围的内容是一个<code>awk</code>程序（program），即模式-动作语句（pattern-action）</li></ul><h2 id="3-3-pattern详细说明"><a href="#3-3-pattern详细说明" class="headerlink" title="3.3 pattern详细说明"></a>3.3 pattern详细说明</h2><ul><li><code>pattern</code>，即模式，是决定<code>awk</code>程序中定义的动作action是否能够被执行的关键</li><li><code>pattern</code>支持的规则：正则表达式，字符串与数字比较，流程控制语句</li></ul><h4 id="例二：pattern——控制输出条件1"><a href="#例二：pattern——控制输出条件1" class="headerlink" title="例二：pattern——控制输出条件1"></a>例二：pattern——控制输出条件1</h4><p>问题描述：</p><ul><li><code>file1</code>文件第一列为员工名字，第二列为时薪，第三列为工作时长</li><li>打印输出时薪大于等于50的员工名字和总薪资</li></ul><p>执行命令：</p><pre><code class="bash">[root@CentOS7 commands]# cat file1Sam    50    8Jiangle    55    9Tom    40    6Tim    60    9[root@CentOS7 commands]# awk &#39;$2&gt;=50 {print $1,$2*$3}&#39; file1Sam 400Jiangle 495Tim 540</code></pre><p><strong>说明：</strong></p><ul><li>其中模式<code>pattern</code>为<code>&#39;$2&gt;=50&#39;</code>，表示扫描每一个输入的行，如果第二列大于0，则执行动作<code>action</code>，否则不执行<code>action</code></li><li>动作<code>action</code>为<code>&#39;{ print $1,$2*$3 }&#39;</code>,模式匹配成功后执行的对应动作，该动作用于打印输出第一个字段和第二、三字段的乘积</li></ul><h3 id="模式表示方式汇总："><a href="#模式表示方式汇总：" class="headerlink" title="模式表示方式汇总："></a>模式表示方式汇总：</h3><table><thead><tr><th>模式</th><th align="center">说明</th></tr></thead><tbody><tr><td><code>/regexp/</code></td><td align="center">正则之字符串匹配模式/regexp/（拓展的正则表达式）<br />例如：expression ~ /regexpr/表示当前输入行包含能被regexpr匹配的子字符串时，该模式被匹配</td></tr><tr><td><code>relational expression</code></td><td align="center">当表达式拥有一个数值形式的值，运算符要求一个字符串值，则awk会将该数值自动转换成字符串<br />当表达式拥有一个字符串形式的值，运算符要求一个数值，则awk会将该字符串值自动转换成数值<br />关于表达式真与假的说明：如果一个表达式，对当前述入行的求值结果非零或不为空，那么该行就被匹配<br />如果比较字符串，比较时是逐字符依赖ASCII字符表比较</td></tr><tr><td><code>pattern 1 &amp;&amp; pattern2</code></td><td align="center">只有当pattern1和pattern2都匹配了，才会执行action</td></tr><tr><td>`pattern1</td><td align="center"></td></tr></tbody></table><h3 id="比较运算符汇总"><a href="#比较运算符汇总" class="headerlink" title="比较运算符汇总"></a>比较运算符汇总</h3><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>==</td><td>等于</td></tr><tr><td>!=</td><td>不等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>~</td><td>匹配</td></tr><tr><td>!~</td><td>不匹配</td></tr></tbody></table><h3 id="表达式运算符汇总（也可以用在action）"><a href="#表达式运算符汇总（也可以用在action）" class="headerlink" title="表达式运算符汇总（也可以用在action）"></a>表达式运算符汇总（也可以用在action）</h3><table><thead><tr><th>操作</th><th>运算符</th><th>举例</th></tr></thead><tbody><tr><td>赋值</td><td>=、+=、-=、*=、/=、^=</td><td><code>sum+=i</code>，即<code>sum=sum+i</code></td></tr><tr><td>条件表达式</td><td>？:</td><td><code>x?y:z</code>，若x为真则为y，否则为z</td></tr><tr><td>逻辑或</td><td>||</td><td><code>x||y</code>，x或y为真，则表达式为真</td></tr><tr><td>逻辑与</td><td>&amp;&amp;</td><td><code>x&amp;&amp;y</code>，x与y为真，则表达式为真</td></tr><tr><td>数组成员</td><td>in</td><td><code>i in a</code>，i在a中</td></tr><tr><td>字段</td><td>$</td><td><code>$1</code> 表示输入行的第一个字段</td></tr><tr><td>组合</td><td>(  )</td><td><code>$(2+1)</code> 表示第三个字段</td></tr><tr><td>匹配<br />不匹配</td><td>~<br />!~</td><td></td></tr><tr><td>自增<br />自减</td><td>++<br />–</td><td></td></tr></tbody></table><h4 id="例三：pattern——控制输出条件2"><a href="#例三：pattern——控制输出条件2" class="headerlink" title="例三：pattern——控制输出条件2"></a>例三：pattern——控制输出条件2</h4><p>问题描述：</p><ul><li>打印输出<code>file2</code>第一和二个字段都为数字或第三和四个字段都为字母的行</li></ul><p>执行命令：</p><pre><code class="bash">[root@CentOS7 commands]# cat file21 2 3 41 2 a ba 1 4 31 a 2 b[root@CentOS7 commands]# awk &#39;($1~/[0-9]/ &amp;&amp; $2~/[0-9]/)||($3~/[a-zA-Z]/ &amp;&amp; $4~/[a-zA-Z]/)&#39; file21 2 3 41 2 a b</code></pre><p><strong>说明：</strong></p><ul><li><code>$1~/[0-9]/</code>表示匹配第一列中包含数字0-9，其中的<code>pattern</code>为[0-9]</li><li><code>$3~/[a-zA-Z]/</code>表示匹配任意大小写字母</li></ul><h2 id="3-4-action详细说明"><a href="#3-4-action详细说明" class="headerlink" title="3.4 action详细说明"></a>3.4 action详细说明</h2><h3 id="关键字和变量"><a href="#关键字和变量" class="headerlink" title="关键字和变量"></a>关键字和变量</h3><ul><li><strong>关键字</strong></li></ul><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td><code>BEGIN</code></td><td>放在程序开头，当<code>awk</code>从输入流中读取数据之前，<code>BEGIN</code>语句开始执行（初始化），可以执行多个<code>BEGIN</code></td></tr><tr><td><code>END</code></td><td>放在程序末尾，当所有输入流被读取完毕，<code>END</code>语句开始执行（扫尾），可以执行多个<code>END</code></td></tr></tbody></table><ul><li><strong>内建变量</strong></li></ul><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td><code>$n</code></td><td>当前记录的第n个字段，字段间由FS分隔</td></tr><tr><td><code>$0</code></td><td>完整的输入记录</td></tr><tr><td><code>FS</code></td><td>Field Separator，表示字符分隔符，即读取输入流时，以FS作为字段分隔的依据，默认为空格符</td></tr><tr><td><code>RS</code></td><td>Record Separator，表示记录分隔符，即读取输入流时，以RS作为记录分隔的依据，默认是一个换行符</td></tr><tr><td><code>OFS</code></td><td>Output Field Separator，表示输出字段分隔符，默认为空格符</td></tr><tr><td><code>ORS</code></td><td>Output Record Separator，表示输出记录分隔符，默认为换行符</td></tr><tr><td><code>NF</code></td><td>Number of Field，表示每一行的字段数目</td></tr><tr><td><code>NR</code></td><td>Number of Row，记录读取的行的行号</td></tr><tr><td><code>IGNORECASE</code></td><td>IGNORECASE如果为真，则进行忽略大小写的匹配</td></tr></tbody></table><h4 id="例四：action——控制语句输出1"><a href="#例四：action——控制语句输出1" class="headerlink" title="例四：action——控制语句输出1"></a>例四：action——控制语句输出1</h4><p>问题描述：</p><ul><li><code>file1</code>文件第一列为员工名字，第二列为时薪，第三列为工作时长</li><li>打印输出每一个员工名字和总薪资，添加一个表头说明，中间用”:”隔开</li></ul><p>执行命令：</p><pre><code class="bash">[root@CentOS7 commands]# cat file1Sam    50    8Jiangle    55    9Tom    40    6Tim    60    9[root@CentOS7 commands]# awk &#39;BEGIN{OFS=&quot;:&quot;;ORS=&quot;\n\n&quot;} BEGIN{print &quot;name:total_salary&quot;} {print $1,$2*$3}&#39; file1name:total_salarySam:400Jiangle:495Tom:240Tim:540</code></pre><p><strong>说明：</strong></p><ul><li>第一个<code>BEGIN</code>语句是控制输出字段分隔符<code>OFS</code>和输出记录分隔符<code>ORS</code></li><li>第二个<code>BEGIN</code>语句是输出字符串<code>&quot;name:total_salary&quot;</code></li><li>执行完两个BEGIN后，<code>awk</code>再从输入流中读取处理数据</li><li>注意：对变量<code>FS</code>、<code>OFS</code>和<code>ORS</code>赋值时，需要使用双引号，不能没有引号或使用单引号</li></ul><h3 id="格式化输出语句"><a href="#格式化输出语句" class="headerlink" title="格式化输出语句"></a>格式化输出语句</h3><p><code>action</code>的格式化输出语句通过<code>printf</code>实现，在<code>print</code>语句中，多个变量之间使用逗号作为分隔符，对变量进行分隔</p><ul><li><strong>printf语法格式：</strong><code>printf(format，expression1，expression2…)</code></li><li>参数<code>format</code>包含“%”、对齐方式、格式控制字符、字符串最大宽度</li></ul><h3 id="printf格式控制字符"><a href="#printf格式控制字符" class="headerlink" title="printf格式控制字符"></a>printf格式控制字符</h3><table><thead><tr><th>格式字符</th><th>说明</th></tr></thead><tbody><tr><td><code>-</code></td><td>左对齐修饰符，默认为右对齐</td></tr><tr><td><code>#</code></td><td>显示8 进制整数时在前面加个0<br/>显示16 进制整数时在前面加0x</td></tr><tr><td><code>+</code></td><td>显示使用d 、e 、f 和g 转换的整数时，加上正负号±</td></tr><tr><td><code>0</code></td><td>用0而不是空白符来填充所显示的值，即用字符’0’填充</td></tr><tr><td><code>%c</code></td><td>表示一个ASCII字符</td></tr><tr><td><code>%s</code></td><td>表示一个字符串</td></tr><tr><td><code>%d</code></td><td>表示一个十进制整数</td></tr><tr><td><code>%u</code></td><td>表示一个无符号的十进制数</td></tr><tr><td><code>%x</code></td><td>表示一个十六进制数</td></tr><tr><td><code>%o</code></td><td>表示一个八进制数</td></tr><tr><td><code>%f</code></td><td>表示一个浮点数</td></tr><tr><td><code>%e</code></td><td>用科学计数法(e 记数法)，表示一个浮点数</td></tr><tr><td><code>%g</code></td><td>选择e或f中较短的一种形式</td></tr></tbody></table><p>上面差不多就是<code>printf</code>的常用格式输出了，下面是一些常用的复合。就是啊，附和！！！</p><p><img src="https://img-blog.csdnimg.cn/20200612215225198.jpg#pic_center" alt="hahaa"></p><table><thead><tr><th>复合格式字符</th><th>说明</th></tr></thead><tbody><tr><td><code>%10d</code></td><td>十进制数占10列</td></tr><tr><td><code>%010d</code></td><td>十进制数占10列，前面用字符’0’填充</td></tr><tr><td><code>%+10d</code></td><td>十进制数占10列，包含数值的符号(±)</td></tr><tr><td><code>%#10x</code></td><td>十六进制数占10列，显示前缀0x</td></tr><tr><td><code>%-10.3f</code></td><td>浮点数左对齐占10列，保留3位小数</td></tr><tr><td><code>%0+10.3f</code></td><td>浮点数右对齐占10列，保留3位小数，显示符号，左补齐填充字符’0’</td></tr><tr><td><code>%10s</code></td><td>字符串右对齐，占10列</td></tr><tr><td><code>%-10s</code></td><td>字符串左对齐，占10列</td></tr></tbody></table><h4 id="例五：action——控制语句输出2"><a href="#例五：action——控制语句输出2" class="headerlink" title="例五：action——控制语句输出2"></a>例五：action——控制语句输出2</h4><p>问题描述：</p><ul><li><code>file1</code>文件第一列为员工名字，第二列为时薪，第三列为工作时长</li><li>打印输出每一个员工编号（所在行数即为编号）、名字和总薪资；员工编号左对齐占5列，名字右对齐占10列，总薪资占10列右对齐保留两位小数</li></ul><p>执行命令：</p><pre><code class="bash">[root@CentOS7 commands]# cat file1Sam    50    8Jiangle    55    9Tom    40    6Tim    60    9[root@CentOS7 commands]# awk &#39;BEGIN{printf &quot;%-5s%10s%10s\n&quot;,&quot;ID&quot;,&quot;NAME&quot;,&quot;SALARY&quot;}{printf(&quot;%-5d%10s%10.2f\n&quot;,NR,$1,$(NF-1)*$NF))}&#39; file1ID         NAME    SALARY1           Sam    400.002       Jiangle    495.003           Tom    240.004           Tim    540.00</code></pre><p><strong>说明：</strong></p><ul><li><code>NF</code>表示当前行的字段数（列数），<code>$NF</code>表示当前行的最后一个字段值</li><li>这里的<code>$(NF-1)*$NF</code>与<code>$2*$3</code>相同</li><li><code>printf</code>不会自动换行，需要添加换行符<code>&quot;\n&quot;</code>才能换行</li></ul><h1 id="四、awk进阶"><a href="#四、awk进阶" class="headerlink" title="四、awk进阶"></a>四、awk进阶</h1><h2 id="4-1-输出重定向"><a href="#4-1-输出重定向" class="headerlink" title="4.1 输出重定向"></a>4.1 输出重定向</h2><h3 id="4-1-2-输出重定向到文件"><a href="#4-1-2-输出重定向到文件" class="headerlink" title="4.1.2 输出重定向到文件"></a>4.1.2 输出重定向到文件</h3><ul><li>使用<code>&gt;&gt;</code>重定向，不清空文件内容，将内容追加到文件尾部</li><li>使用<code>&gt;</code>重定向，清空文件内容，再把内容写入文件</li></ul><h4 id="例六：输出重定向到文件"><a href="#例六：输出重定向到文件" class="headerlink" title="例六：输出重定向到文件"></a>例六：输出重定向到文件</h4><p>问题描述：</p><ul><li><code>file1</code>文件第一列为员工名字，第二列为时薪，第三列为工作时长</li><li>将时薪大于等于50的员工的信息保存到<code>new_file1</code>中</li></ul><p>执行命令：</p><pre><code class="bash">[root@CentOS7 commands]# cat file1Sam    50    8Jiangle    55    9Tom    40    6Tim    60    9[root@CentOS7 commands]# awk &#39;$2&gt;=50 {print $0 &gt; &quot;new_file1&quot;}&#39; file1[root@CentOS7 commands]# cat new_file1 Sam    50    8Jiangle    55    9Tim    60    9</code></pre><p><strong>说明：</strong></p><ul><li>重定向时，文件名必须要用<strong>双引号</strong>引起来，否则会被当作一个未初始化的变量</li><li><code>&gt;</code>重定向时，会覆盖目标文件的内容</li></ul><h3 id="4-1-2-输出重定向到管道"><a href="#4-1-2-输出重定向到管道" class="headerlink" title="4.1.2 输出重定向到管道"></a>4.1.2 输出重定向到管道</h3><ul><li>使用管道命令<code>|</code>进行数据的处理</li></ul><h4 id="例七：输出重定向到管道"><a href="#例七：输出重定向到管道" class="headerlink" title="例七：输出重定向到管道"></a>例七：输出重定向到管道</h4><p>问题描述：</p><ul><li><code>file1</code>文件第一列为员工名字，第二列为时薪，第三列为工作时长</li><li>按照总薪资降序进行排序，名字占10列左对齐，时薪占10列左对齐，工作时长占10列左对齐，总薪资占10列左对齐</li></ul><p>执行命令：</p><pre><code class="bash">[root@CentOS7 commands]# cat file1Sam    50    8Jiangle    55    9Tom    40    6Tim    60    9[root@CentOS7 commands]# awk &#39;{printf(&quot;%-10s%-10d%-10d%-10d\n&quot;,$1,$2,$3,$2*$3) | &quot;sort -nrk 4 &quot;}&#39; file1Tim       60        9         540       Jiangle   55        9         495       Sam       50        8         400       Tom       40        6         240       </code></pre><p><strong>说明：</strong></p><ul><li>语句<code>{printf(...) | &quot;sort...&quot;}</code>中的<code>sort</code>必须用<strong>双引号</strong>引起来</li><li><code>sort</code>中<code>-n</code>表示按照字符串的数值顺序比较；<code>-r</code>表示逆序比较，默认为升序；<code>-k 4</code> 表示以第4个字段（第4列）为关键字进行比较</li><li>也可以将<code>awk</code>的格式化输出通过管道传递给<code>sort</code>命令，也能实现排序并格式化输出，等价命令为：<code>awk &#39;{printf(&quot;%-10s%-10d%-10d%-10d\n&quot;,$1,$2,$3,$2*$3)}&#39; file1 | sort -nrk 4</code></li></ul><h2 id="4-2-流程控制"><a href="#4-2-流程控制" class="headerlink" title="4.2 流程控制"></a>4.2 流程控制</h2><p>流程控制语句中，<code>if-else</code>用于决策，<code>while</code>、<code>for</code>、<code>do whlie</code>用于循环，<code>break</code>、<code>continue</code>用于控制循环</p><h3 id="4-2-1-if-else语句"><a href="#4-2-1-if-else语句" class="headerlink" title="4.2.1 if-else语句"></a>4.2.1 if-else语句</h3><h4 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h4><pre><code class="bash">{    if （expression）        statements    else        statements}</code></pre><p>或者</p><pre><code class="bash">{if (expression) statements;else statements}    </code></pre><h4 id="例八：简单使用if-else语句"><a href="#例八：简单使用if-else语句" class="headerlink" title="例八：简单使用if-else语句"></a>例八：简单使用if-else语句</h4><pre><code class="bash">[root@CentOS7 commands]# cat file1Sam    50    8Jiangle    55    9Tom    40    6Tim    60    9[root@CentOS7 commands]# cat if.awk #!/bin/bash{    if($2&gt;=50)        printf(&quot;%s has a good salary!\n&quot;,$1)        else            printf(&quot;%s need to change a job!\n&quot;,$1)}[root@CentOS7 commands]# awk -f if.awk file1Sam has a good salary!Jiangle has a good salary!Tom need to change a job!Tim has a good salary!</code></pre><p> <strong>说明：</strong></p><ul><li><code>awk -f</code> 可以指定文件作为<code>pattern{action}</code>，上述例子并未指定<code>pattern</code></li><li>从上述例子可以看出，时薪小于50的，就可以换工作了（hahaa，偶尔皮一下🐶）</li></ul><h3 id="4-2-2-while语句"><a href="#4-2-2-while语句" class="headerlink" title="4.2.2 while语句"></a>4.2.2 while语句</h3><h4 id="语法结构-1"><a href="#语法结构-1" class="headerlink" title="语法结构"></a>语法结构</h4><pre><code class="bash">{    while (expression)    {    statement1    statement2    ...    }}</code></pre><p>或者</p><pre><code class="bash">{while (expression){statement1;statement2;...}}</code></pre><h4 id="例九：简单的使用while语句"><a href="#例九：简单的使用while语句" class="headerlink" title="例九：简单的使用while语句"></a>例九：简单的使用while语句</h4><p>问题描述：</p><ul><li>将<code>data</code>文件中的数按行求和并输出</li></ul><p>执行命令：</p><pre><code class="bash">[root@CentOS7 commands]# cat data 1 2 3 45 6 7 8 96 6 6 6 6 610 20 30 40 50 [root@CentOS7 commands]# cat while.awk #!/bin/bash{    i=1    sum=0    while(i&lt;=NF)    {        sum+=$i        i++    }    printf(&quot;Line %d, sum is %d\n&quot;,NR,sum)}[root@CentOS7 commands]# awk -f while.awk dataLine 1, sum is 10Line 2, sum is 35Line 3, sum is 36Line 4, sum is 150</code></pre><p><strong>说明：</strong></p><ul><li>每从输入流读取一行，<code>while</code>循环就会被执行</li><li>当<code>expression</code>的值为真时，进入<code>while</code>循环</li></ul><h3 id="4-2-3-for语句"><a href="#4-2-3-for语句" class="headerlink" title="4.2.3 for语句"></a>4.2.3 for语句</h3><h4 id="语法结构-2"><a href="#语法结构-2" class="headerlink" title="语法结构"></a>语法结构</h4><pre><code class="bash">{    for(expresion1;expression2;expression3)    {        statement1        statement2    }}</code></pre><p>或者</p><pre><code class="bash">{ for(expresion1;expression2;expression3){statement1;statement2;...}}</code></pre><ul><li><code>expression1</code>：进入<code>for</code>循环之前执行一次该语句。一般用于对变量的初始化</li><li><code>expression2</code>：每执行一次循环后，都会执行一次该语句，如果结果为真，则继续循环，反之退出循环。一般用于循环的条件判断</li><li><code>expression3</code>：每执行一次循环后，都会执行一次该语句。一般用于做变量变化</li></ul><h4 id="例十：简单的使用for语句"><a href="#例十：简单的使用for语句" class="headerlink" title="例十：简单的使用for语句"></a>例十：简单的使用for语句</h4><p>问题描述：</p><ul><li>将<code>data</code>文件中的数按行求和并输出</li></ul><p>执行命令：</p><pre><code>[root@CentOS7 commands]# cat data 1 2 3 45 6 7 8 96 6 6 6 6 610 20 30 40 50 [root@CentOS7 commands]# cat while.awk #!/bin/bash{    sum=0    for(i=1;i&lt;=NF;i++)        sum+=$i    printf(&quot;Line %d, sum is %d\n&quot;,NR,sum)}[root@CentOS7 commands]# awk -f for.awk dataLine 1, sum is 10Line 2, sum is 35Line 3, sum is 36Line 4, sum is 150</code></pre><p>循环语句里面也可以使用<code>break</code>、<code>continue</code>语句，具体的使用这里就不再赘述了。</p><p>我的🐴🦆，8k+字！！！第一次总结这么多，累辽~~</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux日常学习——Shell函数</title>
      <link href="/2020/06/02/Linux_Shell%E5%87%BD%E6%95%B0/"/>
      <url>/2020/06/02/Linux_Shell%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h1 id="1-Shell函数的好处"><a href="#1-Shell函数的好处" class="headerlink" title="1. Shell函数的好处"></a>1. Shell函数的好处</h1><p><strong>1. 简化程序代码，实现代码重用</strong></p><ul><li>实现一次定义多次调用。如：is_root_user（）函数可 以由不同的shell脚本重复使用。 </li></ul><p><strong>2. 实现结构化编程</strong> </p><ul><li>使脚本内容更加简洁，增强程序的易读性</li></ul><p><strong>3. 提高执行效率</strong></p><ul><li>将常用的功能定义为多个函数并将其保存在一个文件中，类似其他语言的“模块”文件</li><li>在 <code>~/bashrc</code> 里或命令行上使用 <code>source</code> 命令调用这个文件 </li><li>此文件中定义的多个函数一次性地调入内存，从而加快运行速度</li></ul><h1 id="2-函数的定义和调用"><a href="#2-函数的定义和调用" class="headerlink" title="2. 函数的定义和调用"></a>2. 函数的定义和调用</h1><p><strong>1. 函数定义</strong></p><p>function 函数名 { commands }</p><p>函数名 () { commands }</p><p><strong>2. 函数调用</strong></p><p>只需输入函数名即可调用函数，函数必须在调用之前定义</p><p>函数名<br>函数名 参数1  参数2  …</p><h1 id="3-函数的存储和显示"><a href="#3-函数的存储和显示" class="headerlink" title="3. 函数的存储和显示"></a>3. 函数的存储和显示</h1><p><strong>1. 函数的存储</strong></p><ul><li><p>函数和调用它的主程序保存在同一个文件中 </p><p>函数的定义必须出现在调用之前</p></li><li><p>函数和调用它的主程序保存在不同的文件中</p><p>保存函数的文件必须先使用 <code>source</code> 命令执行，之后才 能调用其中的函数</p></li></ul><p><strong>2. 函数的显示</strong> </p><ul><li><p>显示当前Shell可见的所有函数名 </p><pre><code class="bash">$ declare -F</code></pre></li><li><p>显示当前Shell可见的所有（指定）的函数定义 </p><pre><code class="bash">$ declare -f $ declare -f  &lt;functionName&gt; </code></pre></li></ul><h1 id="4-函数的调用举例"><a href="#4-函数的调用举例" class="headerlink" title="4. 函数的调用举例"></a>4. 函数的调用举例</h1><ul><li><strong>函数和调用它的主程序保存在同一个文件中</strong> </li></ul><pre><code class="bash">#!/bin/bash ## filename: function-1.sh ### User define Function (UDF) ### sql_bak () { echo &quot;Running mysqldump tool...&quot;; } sync_bak () { echo &quot;Running rsync tool...&quot;; } git_bak () { echo &quot;Running gistore tool...&quot;; } tar_bak () { echo &quot;Running tar tool...&quot;; } ### Main script starts here ### PS3=&quot;Please choose a backup tools : &quot; select s in mysqldump rsync gistore tar quit ; do     case $REPLY in        1) sql_bak  ;;         2) sync_bak ;;         3) git_bak  ;;         4) tar_bak  ;;         5) exit     ;;     esac done</code></pre><ul><li><strong>函数和调用它的主程序保存在不同的文件</strong></li></ul><pre><code class="bash">#!/bin/bash ## filename: function-2.sh ### User define Function (UDF) ### sql_bak () { echo &quot;Running mysqldump tool...&quot;; } sync_bak () { echo &quot;Running rsync tool...&quot;; } git_bak () { echo &quot;Running gistore tool...&quot;; } tar_bak () { echo &quot;Running tar tool...&quot;; } </code></pre><pre><code class="bash">#!/bin/bash source /root/bin/function-2.sh ### Main script starts here ### PS3=&quot;Please choose a backup tools : &quot; select s in mysqldump rsync gistore tar quit ; do    case $REPLY in         1|[mM]ysqldump) sql_bak  ;;         2|[rR]sync)     sync_bak ;;         3|[gG]istore)   git_bak  ;;         4|[tT]ar)       tar_bak  ;;         5) exit     ;;     esac done</code></pre><h1 id="5-参数与变量"><a href="#5-参数与变量" class="headerlink" title="5. 参数与变量"></a>5. 参数与变量</h1><p><strong>1. 参数</strong></p><ul><li>调用函数时，使用位置参数的形式为函数传递参数 </li><li>函数内的$1-${n}、$*和$@表示接收到的参数<ul><li>$1-${n}表示第n个参数</li><li>$*表示将所有位置参量看成一个字符串</li><li>$@表示将每个位置参量看成单独的字符串（以空格间隔） </li></ul></li><li>函数调用结束后位置参数$1-${n}、 $* 和 $@ 将被重置为调用函数之前的值 </li><li>在主程序和函数中，$0始终代表脚本名</li></ul><p><strong>2. 变量</strong></p><ul><li><p>函数内使用 local 声明的变量是局部变量 </p><p>局部变量的作用域是当前函数以及其调用的所有函数 </p></li><li><p>函数内未使用 local 声明的变量是全局变量 </p><p>主程序和函数中的同名变量是一个变量（地址一致）</p></li></ul><h1 id="6-函数的结束和返回值"><a href="#6-函数的结束和返回值" class="headerlink" title="6. 函数的结束和返回值"></a>6. 函数的结束和返回值</h1><ul><li><strong>当函数的最后一条命令执行结束，函数结束</strong><ul><li>函数的返回值就是最后一条命令的退出码</li><li>其返回值被保存在系统变量<code>$?</code>中</li></ul></li><li><strong>可以使用return 或exit显示地结束函数</strong><ul><li><code>return [N]</code><ul><li><code>return</code>将结束函数的执行<ul><li>可以使用N指定返回值</li></ul></li></ul></li><li><code>exit [N]</code><ul><li><code>exit</code>将中断当前函数和当前Shell的执行<ul><li>可以使用N指定返回值</li></ul></li></ul></li></ul></li></ul><p><strong>return只能返回整数值</strong>，可以使用标准输出实现函数的返回值</p><ul><li><strong>标准输出实现函数的返回值</strong><ul><li>通用的方法，既能返回整数又能返回字符串</li><li>函数结束前使用 <code>echo</code> 命令将结果显示到标准输出 </li><li>调用函数时使用如下的格式将函数的输出结果存到变量<code>RES</code>中，之后便可使用变量<code>$RES</code>的值</li></ul></li></ul><h1 id="7-标准输出实现函数的返回值举例"><a href="#7-标准输出实现函数的返回值举例" class="headerlink" title="7. 标准输出实现函数的返回值举例"></a>7. 标准输出实现函数的返回值举例</h1><pre><code class="bash">#!/bin/bash # User define Function (UDF) to_upper () {     local str=&quot;$@&quot;     local output     output=$(tr &#39;[a-z]&#39; &#39;[A-Z]&#39;&lt;&lt;&lt;&quot;${str}&quot;)     echo $output } ### Main script starts here ### to_upper &quot;This Is a TEST&quot; res=$(to_upper &quot;$@&quot;) echo &quot;$res&quot; res=$(to_upper &quot;$1&quot;) [[ $res == &quot;YES&quot; ]] &amp;&amp; echo &quot;Continue...&quot; || echo &quot;Stop&quot; </code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>白嫖系列——WebStorm</title>
      <link href="/2020/05/16/%E7%99%BD%E5%AB%96%E7%B3%BB%E5%88%97_WebStorm/"/>
      <url>/2020/05/16/%E7%99%BD%E5%AB%96%E7%B3%BB%E5%88%97_WebStorm/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><blockquote><p>仅供学习交流使用，请支持正版，谢谢合作（白嫖，它不香么？）</p></blockquote><h1 id="1-下载软件"><a href="#1-下载软件" class="headerlink" title="1. 下载软件"></a>1. 下载软件</h1><p>官方下载地址：<a href="https://www.jetbrains.com/webstorm/download/" target="_blank" rel="noopener">https://www.jetbrains.com/webstorm/download/</a></p><p>百度网盘下载链接：<a href="https://pan.baidu.com/s/19h9uKAeJJJ08-n4K-5misg" target="_blank" rel="noopener">https://pan.baidu.com/s/19h9uKAeJJJ08-n4K-5misg</a><br>提取码：<code>4x6n</code></p><h1 id="2-下载白嫖包"><a href="#2-下载白嫖包" class="headerlink" title="2. 下载白嫖包"></a>2. 下载白嫖包</h1><p>百度网盘下载链接：<a href="https://pan.baidu.com/s/1iLCAYK1-k0js8Mjc3Lb2RA" target="_blank" rel="noopener">https://pan.baidu.com/s/1iLCAYK1-k0js8Mjc3Lb2RA</a><br>提取码：<code>mmx9</code></p><h1 id="3-引入包"><a href="#3-引入包" class="headerlink" title="3. 引入包"></a>3. 引入包</h1><ol><li>鼠标右键点击WebStorm的图标，点击<code>打开文件所在位置</code>，将这三个文件复制到安装目录下。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200516161539883.png#pic_center" alt="破解文件"></p><ol start="2"><li>鼠标右键点击<code>地址栏</code>，点击<code>复制地址</code>，我这里的地址为：</li></ol><pre><code class="bash">D:\Program Files\JetBrains\WebStorm 2018.2.3\bin</code></pre><ol start="3"><li>用记事本打开<code>webstorm.exe.vmoptions</code>文件，把最后一行改成：</li></ol><pre><code class="bash">-javaagent:刚刚复制的地址\JetbrainsCrack.jar</code></pre><ol start="4"><li>以同样的方式修改<code>webstorm64.exe.vmoptions</code> 文件。</li></ol><h1 id="4-输入激活码"><a href="#4-输入激活码" class="headerlink" title="4. 输入激活码"></a>4. 输入激活码</h1><ol><li>打开我分享的<code>激活码.txt</code>，<code>Ctrl+A</code>全选，<code>Ctrl+C</code>复制</li></ol><p><img src="https://img-blog.csdnimg.cn/20200516161618993.png#pic_center" alt="激活码"></p><ol start="2"><li>打开WebStorm，输入激活码。激活完成！</li></ol>]]></content>
      
      
      <categories>
          
          <category> 白嫖系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 白嫖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora基础教程——快捷键篇</title>
      <link href="/2020/05/16/Typora_%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2020/05/16/Typora_%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="1-视图操作快捷"><a href="#1-视图操作快捷" class="headerlink" title="1. 视图操作快捷"></a>1. 视图操作快捷</h1><table><thead><tr><th align="center">功能</th><th align="center">快捷键</th></tr></thead><tbody><tr><td align="center">大纲视图</td><td align="center">Ctrl+Shift+1</td></tr><tr><td align="center">文件列表视图</td><td align="center">Ctrl+Shift+2</td></tr><tr><td align="center">放大视图</td><td align="center">Ctrl+Shift+‘+’</td></tr><tr><td align="center">缩小视图</td><td align="center">Ctrl+Shift+‘-’</td></tr><tr><td align="center">源代码模式</td><td align="center">Ctrl+/</td></tr><tr><td align="center">专注模式(当前编辑行为黑，其他行为灰色)</td><td align="center">F8</td></tr><tr><td align="center">打字机模式(光标始终在屏幕中央位置)</td><td align="center">F9</td></tr></tbody></table><h1 id="2-标题段落快捷键"><a href="#2-标题段落快捷键" class="headerlink" title="2. 标题段落快捷键"></a>2. 标题段落快捷键</h1><p><code>MarkDown</code>支持6级标题，可以使用<code>Ctrl+数字</code> 指定不同层次的标题和段落</p><table><thead><tr><th align="center">功能</th><th align="center">快捷键</th></tr></thead><tbody><tr><td align="center">正文</td><td align="center">Ctrl + 0</td></tr><tr><td align="center">1级标题</td><td align="center">Ctrl + 1</td></tr><tr><td align="center">2级标题</td><td align="center">Ctrl + 2</td></tr><tr><td align="center">k级标题</td><td align="center">Ctrl + k</td></tr><tr><td align="center">6级标题</td><td align="center">Ctrl + 6</td></tr><tr><td align="center">提升标题级别</td><td align="center">Ctrl + ‘+’</td></tr><tr><td align="center">降低标题级别</td><td align="center">Ctrl + ‘-</td></tr></tbody></table><h1 id="3-字体操作快捷键"><a href="#3-字体操作快捷键" class="headerlink" title="3. 字体操作快捷键"></a>3. 字体操作快捷键</h1><table><thead><tr><th align="center">功能</th><th align="center">快捷键</th></tr></thead><tbody><tr><td align="center">字体加粗</td><td align="center">Ctrl + B</td></tr><tr><td align="center">下划线</td><td align="center">Ctrl + U</td></tr><tr><td align="center">倾斜</td><td align="center">Ctrl + I</td></tr><tr><td align="center">删除线</td><td align="center">Alt + Shift + 5</td></tr></tbody></table><h1 id="4-插入功能快捷键"><a href="#4-插入功能快捷键" class="headerlink" title="4. 插入功能快捷键"></a>4. 插入功能快捷键</h1><table><thead><tr><th align="center">功能</th><th align="center">快捷键</th></tr></thead><tbody><tr><td align="center">插入图片</td><td align="center">Ctrl+Shift+I</td></tr><tr><td align="center">插入表格</td><td align="center">Ctrl+T</td></tr><tr><td align="center">插入有序列表</td><td align="center">Ctrl+Shift+[</td></tr><tr><td align="center">插入无序列表</td><td align="center">Ctrl+Shift+]</td></tr><tr><td align="center">插入超链接</td><td align="center">Ctrl+K</td></tr><tr><td align="center">插入代码片</td><td align="center">Ctrl+Shift+`</td></tr><tr><td align="center">插入代码块</td><td align="center">Ctrl+Shift+K</td></tr><tr><td align="center">插入公式块</td><td align="center">Ctrl+Shift+M</td></tr><tr><td align="center">插入引用块</td><td align="center">Ctrl+Shift+Q</td></tr></tbody></table><h1 id="5-表格扩展快捷键"><a href="#5-表格扩展快捷键" class="headerlink" title="5. 表格扩展快捷键"></a>5. 表格扩展快捷键</h1><table><thead><tr><th align="center">功能</th><th align="center">快捷键</th></tr></thead><tbody><tr><td align="center">下方插入行</td><td align="center">Ctrl+Enter（回车）</td></tr><tr><td align="center">删除该行</td><td align="center">Shift+Ctrl+BackSpace（退格）</td></tr><tr><td align="center">上移该行</td><td align="center">Shift+Ctrl+↑</td></tr><tr><td align="center">下移该行</td><td align="center">Shift+Ctrl+↓</td></tr><tr><td align="center">左移该列</td><td align="center">Shift+Ctrl+←</td></tr><tr><td align="center">右移该列</td><td align="center">Shift+Ctrl+→</td></tr></tbody></table><h1 id="6-跳转操作"><a href="#6-跳转操作" class="headerlink" title="6. 跳转操作"></a>6. 跳转操作</h1><table><thead><tr><th align="center">功能</th><th align="center">快捷键</th></tr></thead><tbody><tr><td align="center">跳转到文首</td><td align="center">Ctrl+Home<br />Ctrl+Fn+←</td></tr><tr><td align="center">跳转到所选内容</td><td align="center">Ctrl+J</td></tr><tr><td align="center">跳转到文末</td><td align="center">Ctrl+End<br />Ctrl+Fn+→</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Typora </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7 添加一个简单的系统调用（内核模块法）</title>
      <link href="/2020/04/23/Linux_CentOS7%E6%B7%BB%E5%8A%A0%E7%AE%80%E5%8D%95%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%94%A8-%E6%A8%A1%E5%9D%97%E6%B3%95/"/>
      <url>/2020/04/23/Linux_CentOS7%E6%B7%BB%E5%8A%A0%E7%AE%80%E5%8D%95%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%94%A8-%E6%A8%A1%E5%9D%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><hr><h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><ol><li>学习Linux的内核的系统调用。</li><li>理解、掌握Linux系统调用的实现框架、用户界面、参数传递、进入/返回过程。</li></ol><hr><h1 id="二、实验内容"><a href="#二、实验内容" class="headerlink" title="二、实验内容"></a>二、实验内容</h1><p>在系统调用中添加一个不用传递参数的系统调用，实现一个简单的系统调用的添加。执行这个系统调用，在屏幕上显示输出“Hello World! ”。</p><hr><h1 id="三、实验环境"><a href="#三、实验环境" class="headerlink" title="三、实验环境"></a>三、实验环境</h1><p>虚拟机软件：Vmware Workstation<br>Linux发行版：CentOS 7  内置内核：linux 3.10.0<br>待编译内核：linux 4.15.10</p><hr><h1 id="四、操作方法和步骤"><a href="#四、操作方法和步骤" class="headerlink" title="四、操作方法和步骤"></a>四、操作方法和步骤</h1><h2 id="（1）准备工作"><a href="#（1）准备工作" class="headerlink" title="（1）准备工作"></a>（1）准备工作</h2><ol><li>查询syscall_table的地址，执行命令：<pre><code class="bash">sudo cat /proc/kallsyms | grep sys_call_table</code></pre><img src="https://img-blog.csdnimg.cn/20200423230707376.png#pic_center" alt="查询syscall_table地址"></li><li>查询可用的系统调用号，使用vim编辑器打开unistd_32.h，执行命令：<pre><code class="bash">vim /usr/include/asm/unistd_32.h</code></pre>在普通模式下，输入<code>G</code>或者<code>shift+g</code>定位到文尾，可以看到最后一个是383，因此384是可用的系统调用号<br><img src="https://img-blog.csdnimg.cn/20200423231432629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MTE2MDA5,size_16,color_FFFFFF,t_70#pic_center" alt="查询可用的系统调用号"></li></ol><h2 id="（2）创建hello-c文件"><a href="#（2）创建hello-c文件" class="headerlink" title="（2）创建hello.c文件"></a>（2）创建hello.c文件</h2><ul><li>sys_call_table为上面查询到的系统调用表的地址，NUM为待添加的系统调用号</li><li>使用<code>vim</code>命令创建<code>hello.c</code>，并添加以下内容：<pre><code class="bash">#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/unistd.h&gt;#include &lt;linux/sched.h&gt;MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);#define SYS_CALL_TABLE_ADDRESS 0xffffffffa8400160  //sys_call_table对应的地址#define NUM 384  //系统调用号为384int orig_cr0;  //用来存储cr0寄存器原来的值unsigned long *sys_call_table_my=0;static int(*anything_saved)(void);  //定义一个函数指针，用来保存一个系统调用static int clear_cr0(void) //使cr0寄存器的第17位设置为0（内核空间可写）{  unsigned int cr0=0;  unsigned int ret;  asm volatile(&quot;movq %%cr0,%%rax&quot;:&quot;=a&quot;(cr0));//将cr0寄存器的值移动到eax寄存器中，同时输出到cr0变量中  ret=cr0;  cr0&amp;=0xfffffffffffeffff;//将cr0变量值中的第17位清0,将修改后的值写入cr0寄存器  asm volatile(&quot;movq %%rax,%%cr0&quot;::&quot;a&quot;(cr0));//将cr0变量的值作为输入，输入到寄存器eax中，同时移动到寄存器cr0中  return ret;}static void setback_cr0(int val) //使cr0寄存器设置为内核不可写{  asm volatile(&quot;movq %%rax,%%cr0&quot;::&quot;a&quot;(val));}asmlinkage long sys_mycall(void) //定义自己的系统调用{     printk(&quot;模块系统调用-当前pid：%d，当前comm:%s\n&quot;,current-&gt;pid,current-&gt;comm);  printk(&quot;hello,world!\n&quot;);  return current-&gt;pid;    }static int __init call_init(void){  sys_call_table_my=(unsigned long*)(SYS_CALL_TABLE_ADDRESS);  printk(&quot;call_init......\n&quot;);  anything_saved=(int(*)(void))(sys_call_table_my[NUM]);//保存系统调用表中的NUM位置上的系统调用  orig_cr0=clear_cr0();//使内核地址空间可写  sys_call_table_my[NUM]=(unsigned long) &amp;sys_mycall;//用自己的系统调用替换NUM位置上的系统调用  setback_cr0(orig_cr0);//使内核地址空间不可写  return 0;}static void __exit call_exit(void){  printk(&quot;call_exit......\n&quot;);  orig_cr0=clear_cr0();  sys_call_table_my[NUM]=(unsigned long)anything_saved;//将系统调用恢复  setback_cr0(orig_cr0);}module_init(call_init);module_exit(call_exit);</code></pre></li></ul><h2 id="（3）创建Makefile文件"><a href="#（3）创建Makefile文件" class="headerlink" title="（3）创建Makefile文件"></a>（3）创建Makefile文件</h2><ul><li>使用<code>vim</code>命令创建Makefile文件，添加以下内容<pre><code class="bash">obj-m:=hello.oCURRENT_PATH:=$(shell pwd)LINUX_KERNEL_PATH:=/usr/src/linux-4.15.10all:  make -C  $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modulesclean:  make -C  $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean</code></pre></li><li><strong>注意：</strong><code>LINUX_KERNEL_PATH</code>是内核代码的位置</li></ul><h2 id="（4）安装内核模块"><a href="#（4）安装内核模块" class="headerlink" title="（4）安装内核模块"></a>（4）安装内核模块</h2><ol><li>执行命令:<pre><code class="c">make</code></pre></li><li>查看make是否成功，执行命令：<pre><code class="bash">ls | grep &#39;hello.*&#39;</code></pre>看到有<code>ko</code>，<code>mod.c</code>，<code>mod.o</code>文件就说明成功了</li><li>使用insmod插入模块，执行命令：<pre><code class="bash">insmod hello.ko</code></pre></li><li>使用lsmod查看模块是否插入成功，执行命令：<pre><code class="bash">lsmod</code></pre><code>Module</code>出现hello，表示模块插入成功</li></ol><h2 id="（5）测试系统调用"><a href="#（5）测试系统调用" class="headerlink" title="（5）测试系统调用"></a>（5）测试系统调用</h2><ol><li>使用vim创建test.c文件，执行命令：<pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;linux/kernel.h&gt;#include&lt;sys/syscall.h&gt;#include&lt;unistd.h&gt;int main(){     unsigned long x = 0;     x = syscall(483);        //测试483号系统调用     printf(&quot;17计科-1727405169 syscall result: %ld\n&quot;, x);     return 0;}</code></pre></li><li>使用gcc编译，执行命令：<pre><code class="c">gcc test.c</code></pre></li><li>运行a.out，执行命令：<pre><code class="c">./a.out</code></pre>出现以下结果就成功了。<br><img src="https://img-blog.csdnimg.cn/20200423232810313.png#pic_center" alt="成功运行"></li></ol><hr><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><ul><li>两个字高度概括，<strong>简单！</strong></li><li>剩下的你们自己慢慢写吧，有问题欢迎在留言区交流，谢谢观看。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GithubPages入门教程</title>
      <link href="/2020/04/15/Hexo_GithubPages%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2020/04/15/Hexo_GithubPages%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><hr><h1 id="一、什么是-GitHub-Pages"><a href="#一、什么是-GitHub-Pages" class="headerlink" title="一、什么是 GitHub Pages"></a>一、什么是 GitHub Pages</h1><p>官方给出的说明：您和您的项目的网站，直接从您的GitHub存储库托管。只需编辑，推送，您的更改就会生效。</p><hr><h1 id="二、为什么使用Github-Pages"><a href="#二、为什么使用Github-Pages" class="headerlink" title="二、为什么使用Github Pages"></a>二、为什么使用Github Pages</h1><ul><li>搭建简单而且免费</li><li>支持静态脚本</li><li>可以绑定你的域名</li><li>DIY自由发挥，动手实践一些有意思的东西</li><li>写博环境，git+github+markdown+hexo</li></ul><hr><h1 id="三、创建Github-Pages"><a href="#三、创建Github-Pages" class="headerlink" title="三、创建Github Pages"></a>三、创建Github Pages</h1><h2 id="1-创建一个GitHub账号"><a href="#1-创建一个GitHub账号" class="headerlink" title="1. 创建一个GitHub账号"></a>1. 创建一个GitHub账号</h2><ul><li><a href="https://github.com/">github官网</a></li><li>取一个适合的名字，后面会通过username .github.io访问你的主页，username是你的用户名<h2 id="2-创建一个仓库-New-repository"><a href="#2-创建一个仓库-New-repository" class="headerlink" title="2. 创建一个仓库(New repository)"></a>2. 创建一个仓库(New repository)</h2></li><li>右上角点击加号“+”，创建一个仓库<br><img src="https://img-blog.csdnimg.cn/20200414165421417.png#pic_center" alt="创建仓库1"></li><li>名字为username .github.io，username是你的用户名，如果不是你的用户名，它将不起作用，也就不能通过username .github.io访问你的主页<br><img src="https://img-blog.csdnimg.cn/20200414165938252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MTE2MDA5,size_16,color_FFFFFF,t_70#pic_center" alt="创建仓库2"><h2 id="3-创建一个主页文件index-html"><a href="#3-创建一个主页文件index-html" class="headerlink" title="3. 创建一个主页文件index.html"></a>3. 创建一个主页文件index.html</h2></li><li>点击<code>create a new file</code>创建文件<br><img src="https://img-blog.csdnimg.cn/2020041417025843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MTE2MDA5,size_16,color_FFFFFF,t_70#pic_center" alt="创建新文件"></li><li>文件名为index.html，然后点击<code>commit new file</code>提交<br><img src="https://img-blog.csdnimg.cn/20200414170645710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MTE2MDA5,size_16,color_FFFFFF,t_70#pic_center" alt="创建index.html"><br>然后就可以使用<code>username.github.io</code>访问你的主页了<h2 id="4-绑定域名"><a href="#4-绑定域名" class="headerlink" title="4. 绑定域名"></a>4. 绑定域名</h2></li><li>域名可以在阿里云、腾讯云购买，没有的也可以跳过这一步</li><li>绑定域名参考<a href="https://auligey.github.io" target="_blank" rel="noopener">Github pages 绑定个人域名</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一个Markdown文档——Hello.md</title>
      <link href="/2020/04/13/Markdown_%E7%AC%AC%E4%B8%80%E4%B8%AAMarkdown%E6%96%87%E6%A1%A3/"/>
      <url>/2020/04/13/Markdown_%E7%AC%AC%E4%B8%80%E4%B8%AAMarkdown%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><p>打开你熟悉的文本编辑器（如 <a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener">notepad++</a>），新建一个 ‘hello.md’ 文件，写入下面的内容，并保存：</p><pre><code class="c"># Hello World**This is my first time to use Markdown***第一次用文本编辑器写Markdown文档*~~这只是万里长征第一步~~ 但是，万事开头难 有了第一步，坚持下去，定有收获！</code></pre><p>‘.md’ 和 ‘.markdown’ 都是被普遍支持的扩展名，不过 ‘.md’ 更加简单和方便。</p><p>他转换成html文档后，应该是这样子：</p><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p><strong>This is my first time to use Markdown</strong><br><em>第一次用文本编辑器写Markdown文档</em><br><del>这只是万里长征第一步</del><br>但是，万事开头难 有了第一步，坚持下去，定有收获！</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Markdown</title>
      <link href="/2020/04/13/Markdown_%E5%85%B3%E4%BA%8EMarkdown/"/>
      <url>/2020/04/13/Markdown_%E5%85%B3%E4%BA%8EMarkdown/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p><a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">维基百科: Markdown</a></p><blockquote><p>Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John<br>Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者<br>HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p></blockquote><hr><h1 id="2-为什么选择-Markdown"><a href="#2-为什么选择-Markdown" class="headerlink" title="2. 为什么选择 Markdown"></a>2. 为什么选择 Markdown</h1><ul><li>它基于纯文本，方便修改和共享；</li><li>几乎可以在所有的文本编辑器中编写；</li><li>有众多编程语言的实现和应用的相关扩展；</li><li>在 GitHub 等网站中有很好的应用；</li><li>很容易转换为 HTML 文档或其他格式；</li><li>适合用来编写文档、记录笔记、撰写文章。</li></ul><hr><h1 id="3-兼容-HTML"><a href="#3-兼容-HTML" class="headerlink" title="3. 兼容 HTML"></a>3. 兼容 HTML</h1><p>Markdown 完全兼容 HTML 语法，可以直接在 Markdown 文档中插入 HTML 内容：</p><pre><code class="html">&lt;table&gt;  &lt;tr&gt;    &lt;td&gt;1行1列&lt;/td&gt;    &lt;td&gt;1行2列&lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;2行1列&lt;/td&gt;    &lt;td&gt;2行2列&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;</code></pre><p>这段代码会变成下面的样子：</p><table>  <tr>    <td>1行1列</td>    <td>1行2列</td>  </tr>  <tr>    <td>2行1列</td>    <td>2行2列</td>  </tr></table>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-hexo配置首页</title>
      <link href="/2020/04/13/Hexo_3-hexo%E9%85%8D%E7%BD%AE%E9%A6%96%E9%A1%B5/"/>
      <url>/2020/04/13/Hexo_3-hexo%E9%85%8D%E7%BD%AE%E9%A6%96%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="1-首页文件位置-layout-indexs-md"><a href="#1-首页文件位置-layout-indexs-md" class="headerlink" title="1. 首页文件位置/layout/indexs.md"></a>1. 首页文件位置/layout/indexs.md</h1><p>既然是md格式，大家应该都已经熟悉了，这里就不再赘述了~</p><h1 id="2-添加文章数和字数统计"><a href="#2-添加文章数和字数统计" class="headerlink" title="2. 添加文章数和字数统计"></a>2. 添加文章数和字数统计</h1><ul><li>加入含有 class=”article_number”的html标签可显示文章数量。</li><li>加入含有 class=”site_word_count”的html标签可显示站点总字数。</li></ul><pre><code class="bash">&lt;!-- 这里是借用了code的样式，所以直接使用code标签。    自定义样式，可加入style属性设置--&gt;&lt;code class=&quot;article_number&quot;&gt;&lt;/code&gt;&lt;code class=&quot;site_word_count&quot;&gt;&lt;/code&gt;</code></pre><p><strong>上面代码的效果：</strong><br>文章共<code class="article_number"></code>篇；总字数<code class="site_word_count"></code>字；</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7 wget 正在连接 127.0.0.1:8118... 失败：拒绝连接。</title>
      <link href="/2020/04/12/Linux_wget%E6%8B%92%E7%BB%9D%E8%BF%9E%E6%8E%A5/"/>
      <url>/2020/04/12/Linux_wget%E6%8B%92%E7%BB%9D%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><p><strong>正在使用wget下载包的时候，出现了拒绝连接的错误</strong></p><pre><code class="bash">[root@CentOS7 local]# wget http://jaist.dl.sourceforge.net/project/pcre/pcre/8.33/pcre-8.33.tar.gz--2020-04-11 23:46:24--  http://jaist.dl.sourceforge.net/project/pcre/pcre/8.33/pcre-8.33.tar.gz正在连接 127.0.0.1:8118... 失败：拒绝连接。</code></pre><p><strong>查找问题的方法如下：</strong></p><h1 id="1-查看本地端口是否被占用"><a href="#1-查看本地端口是否被占用" class="headerlink" title="1. 查看本地端口是否被占用"></a>1. 查看本地端口是否被占用</h1><pre><code class="bash">[root@CentOS7 local]# netstat -ntplActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      1151/cupsd          tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1480/master         tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      1/systemd           tcp        0      0 192.168.122.1:53        0.0.0.0:*               LISTEN      1612/dnsmasq        tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1150/sshd           tcp6       0      0 ::1:631                 :::*                    LISTEN      1151/cupsd          tcp6       0      0 ::1:25                  :::*                    LISTEN      1480/master         tcp6       0      0 :::111                  :::*                    LISTEN      1/systemd           tcp6       0      0 :::22                   :::*                    LISTEN      1150/sshd           </code></pre><p>本地端口8118并没有被占用</p><h1 id="2-查看本地网络代理"><a href="#2-查看本地网络代理" class="headerlink" title="2. 查看本地网络代理"></a>2. 查看本地网络代理</h1><pre><code class="bash">[root@CentOS7 local]# export | grep -i proxydeclare -x ftp_proxy=&quot;http://127.0.0.1:8118&quot;declare -x http_proxy=&quot;http://127.0.0.1:8118&quot;declare -x https_proxy=&quot;http://127.0.0.1:8118&quot;</code></pre><p>网络http确实有代理，几乎可以断定是这个代理引发的错误。</p><p><strong>解决办法：</strong><br>尝试关闭代理，然后重新使用wget下载</p><pre><code class="bash">[root@CentOS7 local]# unset http_proxy [root@CentOS7 local]# wget http://jaist.dl.sourceforge.net/project/pcre/pcre/8.33/pcre-8.33.tar.gz--2020-04-11 23:48:38--  http://jaist.dl.sourceforge.net/project/pcre/pcre/8.33/pcre-8.33.tar.gz正在解析主机 jaist.dl.sourceforge.net (jaist.dl.sourceforge.net)... 150.65.7.130, 2001:df0:2ed:feed::feed正在连接 jaist.dl.sourceforge.net (jaist.dl.sourceforge.net)|150.65.7.130|:80... 已连接。</code></pre><p><strong>wget连接成功！</strong></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7 添加一个简单的系统调用（内核编译法）</title>
      <link href="/2020/04/07/Linux_CentOS7%E6%B7%BB%E5%8A%A0%E7%AE%80%E5%8D%95%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8_%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B3%95/"/>
      <url>/2020/04/07/Linux_CentOS7%E6%B7%BB%E5%8A%A0%E7%AE%80%E5%8D%95%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8_%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><hr><h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><ol><li>学习Linux的内核的系统调用。</li><li>理解、掌握Linux系统调用的实现框架、用户界面、参数传递、进入/返回过程。</li></ol><h1 id="二、实验内容"><a href="#二、实验内容" class="headerlink" title="二、实验内容"></a>二、实验内容</h1><p>在系统调用中添加一个不用传递参数的系统调用，实现一个简单的系统调用的添加。执行这个系统调用，在屏幕上显示输出“Hello World! ”。</p><hr><h1 id="三、实验环境"><a href="#三、实验环境" class="headerlink" title="三、实验环境"></a>三、实验环境</h1><p>虚拟机软件：Vmware Workstation<br>Linux发行版：CentOS 7  内置内核：linux 3.10.0<br>待编译内核：linux 4.15.10</p><hr><h1 id="四、操作方法和步骤"><a href="#四、操作方法和步骤" class="headerlink" title="四、操作方法和步骤"></a>四、操作方法和步骤</h1><h2 id="（1）下载软件包，并解压"><a href="#（1）下载软件包，并解压" class="headerlink" title="（1）下载软件包，并解压"></a>（1）下载软件包，并解压</h2><ol><li>下载地址：<a href="http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v4.x/" target="_blank" rel="noopener">http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v4.x/</a><br>可以通过<code>Ctrl+F</code>快速查找</li><li>使用<code>tar</code>命令解压文件到/usr/src目录下。执行命令：</li></ol><pre><code class="bash">tar xf ~/Downloads/linux-4.15.10.tar.gz -C /usr/src</code></pre><ol start="3"><li>解压之后，切换工作目录到<code>/usr/src/linux-4.15.10/</code>，可以是用<code>Tab</code>键补全路径。执行命令：</li></ol><pre><code class="bash">cd /usr/src/linux-4.15.10/</code></pre><ol start="4"><li>后面操作大部分都需要root权限，使用<code>su</code>命令切换用户，输入密码时不会显示。执行命令：</li></ol><pre><code class="bash">su root</code></pre><h2 id="（2）修改源程序，增加系统调用"><a href="#（2）修改源程序，增加系统调用" class="headerlink" title="（2）修改源程序，增加系统调用"></a>（2）修改源程序，增加系统调用</h2><p><strong>小提示：</strong> 在vim编辑器里，<code>i</code>字母插入，按<code>esc</code>后输入<code>:wq</code>保存并退出，<code>:q!</code>强制退出</p><ol><li>使用vim编辑<code>arch/x86/entry/syscalls/syscall_64.tbl</code>文件，添加系统调用号，在普通模式下，<code>shift+g</code>或者<code>G</code>可以直接定位到文尾。执行命令：</li></ol><pre><code class="bash">vim arch/x86/entry/syscalls/syscall_64.tbl</code></pre><p>添加两个没有使用(unuse)的系统调用号，其他格式可以参考文件中的其他系统调用，这里我添加了两个系统调用。代码如下：<br><img src="https://img-blog.csdnimg.cn/20200406232920550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MTE2MDA5,size_16,color_FFFFFF,t_70" alt="添加系统调用号">2.使用vim编辑<code>include/linux/syscalls.h</code>文件，添加原型声明。执行命令：</p><pre><code class="bash">vim include/linux/syscalls.h</code></pre><p>不传递参数的时候，void也不能漏写。代码如下：<br><img src="https://img-blog.csdnimg.cn/20200406233121458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MTE2MDA5,size_16,color_FFFFFF,t_70" alt="添加原型声明"></p><ol start="3"><li>使用vim编辑<code>kernel/sys.c</code>文件，实现具体的系统调用。执行命令：</li></ol><pre><code class="bash">vim kernel/sys.c</code></pre><p>代码打一遍印象深刻一些，GoGoGo！代码如下：<br><img src="https://img-blog.csdnimg.cn/20200406233418258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MTE2MDA5,size_16,color_FFFFFF,t_70" alt="系统调用的实现"></p><hr><h2 id="（3）编译内核"><a href="#（3）编译内核" class="headerlink" title="（3）编译内核"></a>（3）编译内核</h2><p>这里就不详细说明了，请参考<a href="https://auligey.github.io/2020/04/05/CentOS7%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8/" target="_blank" rel="noopener">Linux发行版 CentOS编译内核</a></p><hr><h2 id="（4）测试系统调用"><a href="#（4）测试系统调用" class="headerlink" title="（4）测试系统调用"></a>（4）测试系统调用</h2><ol><li>使用vim命令创建测试文件<code>mysyscall.c</code>和<code>mycall.c</code>，下面以mysyscall.c的创建和测试为例。执行命令：</li></ol><pre><code class="bash">vim mysyscall.c</code></pre><p><img src="https://img-blog.csdnimg.cn/20200406233820378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MTE2MDA5,size_16,color_FFFFFF,t_70" alt="测试mysyscall"></p><ol start="2"><li>使用gcc编译c程序文件<br><em>编译的四个阶段</em></li></ol><ul><li>-E：仅执行编译预处理</li><li>-c：仅执行编译操作，不进行连接操作</li><li>-S：将C代码转换为汇编代码</li><li>-o：指定生成的输出文件</li></ul><p>直接使用<code>gcc -o</code>生成指定输出文件。执行命令：</p><pre><code class="bash">gcc -o mysyscall_test mysyscall_test.c   #使用gcc编译</code></pre><p>运行可执行文件，执行命令：</p><pre><code class="bash">./mysyscall_test        # 运行可执行文件</code></pre><p><img src="https://img-blog.csdnimg.cn/20200406234708504.png" alt="gcc编译测试文件并执行"><br>使用<code>dmesg</code>查看printk的输出情况。执行命令：</p><pre><code class="bash">dmesg</code></pre><p><img src="https://img-blog.csdnimg.cn/2020040623462720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MTE2MDA5,size_16,color_FFFFFF,t_70" alt="dmesg输出情况"><br>系统调用的<strong>返回值</strong>和<strong>printk的输出</strong>均符合预期，系统调用成功添加了！</p><hr><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><ul><li>两个字高度概括，<strong>简单！</strong></li><li>剩下的你们自己慢慢写吧，有问题欢迎在留言区交流，谢谢观看。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7 编译内核</title>
      <link href="/2020/04/05/Linux_CentOS7%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8/"/>
      <url>/2020/04/05/Linux_CentOS7%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><hr><h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><ol><li>学习怎样重新编译Linux内核。</li><li>理解、掌握Linux标准内核和发行版本内核的区别。</li></ol><hr><h1 id="二、环境准备"><a href="#二、环境准备" class="headerlink" title="二、环境准备"></a>二、环境准备</h1><p>虚拟机软件：Vmware Workstation<br>Linux发行版：CentOS 7  内置内核：linux 3.10.0<br>待编译内核：linux 4.15.10</p><hr><h1 id="三、操作方法和步骤"><a href="#三、操作方法和步骤" class="headerlink" title="三、操作方法和步骤"></a>三、操作方法和步骤</h1><ul><li>编译过程很多地方需要root权限，为了方便，直接切换到root，切换命令：<pre><code class="bash">su root</code></pre></li><li><strong>小提示</strong>：输入密码时不会显示，<code>$</code>表示一般用户，<code>#</code>表示超级管理员root，<code>Tab</code>键可以补全路径</li></ul><h2 id="（1）下载内核并解压"><a href="#（1）下载内核并解压" class="headerlink" title="（1）下载内核并解压"></a>（1）下载内核并解压</h2><ol><li>使用浏览器打开<a href="http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v4.x/" target="_blank" rel="noopener">http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v4.x/</a></li><li><code>Ctrl+F</code>查找linux-4.15.10.tar.gz，点击即可下载，我下载的位置是<code>/home/username/Downloads/linux-4.15.10.tar.gz</code></li><li>使用<code>tar</code>命令解压文件：<pre><code class="c">tar xf ~/Downloads/linux-4.15.10.tar.gz -C /usr/src</code></pre></li><li>解压之后，切换工作目录：<pre><code class="bash">cd /usr/src/linux-4.15.10/</code></pre></li></ol><h2 id="（2）配置项"><a href="#（2）配置项" class="headerlink" title="（2）配置项"></a>（2）配置项</h2><p><strong>配置项的几种方式</strong></p><ul><li><code>make config</code>         基于文本的配置界面</li><li><code>make menuconfig</code>    基于文本菜单的配置界面</li><li><code>make xconfig</code>        基于图像窗口的配置界面</li><li><code>make oldconfig</code>        基于原来内核配置基础上修改</li></ul><p><strong>本文采用基于文本菜单的配置界面（make menuconfig）</strong></p><ul><li>使用<code>make menuconfig</code>需要<code>ncurses-devel</code>的支持</li><li>安装<code>ncurses-devel</code>命令：<pre><code class="bash">yum install ncurses-devel</code></pre></li><li>执行<code>make menuconfig</code>，开始选择配置项（<strong>注意终端窗口至少为19行，80列，否则报错提示</strong>）<pre><code class="bash">make menuconfig</code></pre></li><li>成功执行后，会出现下面的窗口：<br><img src="https://img-blog.csdnimg.cn/20200405135307329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MTE2MDA5,size_16,color_FFFFFF,t_70#pic_center" alt="menuconfig"></li><li>直接<strong>保存退出</strong>就可以了，它会使用 CentOS 内部的配置文件作为这次编译的配置文件</li></ul><h2 id="（3）编译内核"><a href="#（3）编译内核" class="headerlink" title="（3）编译内核"></a>（3）编译内核</h2><ul><li>编译需要<code>elfutils-libelf-devel</code> 和 <code>openssl-devel</code> 的支持，安装命令：<pre><code class="bash">yum install elfutils-libelf-devel openssl-devel</code></pre></li><li>使用<code>make</code>命令开始编译内核，可以使用多核线程提高编译速度：<pre><code class="bash">make -j4</code></pre></li></ul><p><strong>emmm，编译时间很长(1小时左右，与电脑性能有关)，耐心等待</strong></p><h2 id="（4）安装"><a href="#（4）安装" class="headerlink" title="（4）安装"></a>（4）安装</h2><ul><li>漫长的等待之后，终于迎来了安装内核</li><li>执行 <code>make modules_install</code> 开始安装模块：<pre><code class="bash">make modules_install</code></pre></li><li>等待几分钟，执行<code>make install</code> 开始安装核心：<pre><code class="bash">make install</code></pre></li><li>顺利安装完成，重启虚拟机看看</li></ul><h2 id="（5）重启虚拟机"><a href="#（5）重启虚拟机" class="headerlink" title="（5）重启虚拟机"></a>（5）重启虚拟机</h2><ul><li><p>重启之后，进入grub界面，选择新编译的内核：<code>CentOS Linux （4.15.10）</code></p></li><li><p>进入桌面后，打开终端，使用<code>uname -a</code>查看内核版本：</p><pre><code class="bash">uname -sr</code></pre></li><li><p>实验做完了，才算完成了一半，<strong>还有实验报告没写！haha</strong></p></li></ul><hr><h1 id="四、欠揍式总结（👊警告）"><a href="#四、欠揍式总结（👊警告）" class="headerlink" title="四、欠揍式总结（👊警告）"></a>四、欠揍式总结（👊警告）</h1><ul><li><strong>有啥总结的！不是一番风顺吗？</strong></li><li><strong>Go！ 篮球场约起！</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> 操作系统课程实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-hexo快捷键说明</title>
      <link href="/2020/04/05/Hexo_3-hexo%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AF%B4%E6%98%8E/"/>
      <url>/2020/04/05/Hexo_3-hexo%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="1-说明"><a href="#1-说明" class="headerlink" title="1. 说明"></a>1. 说明</h1><blockquote><p>快捷键为vim风格的，按键可能与vimium（chrome插件）的快捷键有冲突，插件设置屏蔽掉此站的快捷键即可。</p></blockquote><h1 id="2-搜索框"><a href="#2-搜索框" class="headerlink" title="2. 搜索框"></a>2. 搜索框</h1><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>Esc</td><td>1.如果输入框有内容，清除内容 <br />2.如果输入框无内容，失去焦点（普通模式）</td></tr><tr><td>i/I</td><td>获取焦点（插入模式）</td></tr><tr><td>↑</td><td>向下选择文章</td></tr><tr><td>↓</td><td>向上选择文章</td></tr><tr><td>Enter（回车）</td><td>打开当前鼠标选中的文章<br />若没有，则默认打开第一个</td></tr></tbody></table><h1 id="3-全局"><a href="#3-全局" class="headerlink" title="3. 全局"></a>3. 全局</h1><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>s/S</td><td>全屏/取消全屏</td></tr><tr><td>w/W</td><td>打开/关闭文章目录</td></tr><tr><td>j/J</td><td>向下滑动</td></tr><tr><td>k/K</td><td>向上滑动</td></tr><tr><td>gg/GG</td><td>到最顶端</td></tr><tr><td>shift+G/g</td><td>到最下端</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo安装教程</title>
      <link href="/2020/04/04/Hexo_hexo%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2020/04/04/Hexo_hexo%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><hr><h1 id="1-安装前提"><a href="#1-安装前提" class="headerlink" title="1. 安装前提"></a>1. 安装前提</h1><p>安装hexo之前，需要安装下列应用程序：</p><ul><li><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a></li><li><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ul><hr><h2 id="1-1-安装-Git"><a href="#1-1-安装-Git" class="headerlink" title="1.1 安装 Git"></a>1.1 安装 Git</h2><ul><li>Windows：下载并安装 <a href="http://git-scm.com/" target="_blank" rel="noopener">Git(官网)</a>或者<a href="https://npm.taobao.org/mirrors/git-for-windows/" target="_blank" rel="noopener">淘宝 Git for Windows 镜像</a>，安装选项全部默认，在最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>，这样我们就可以直接在命令提示符里打开Git了</li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/" target="_blank" rel="noopener">Homebrew</a>, <a href="http://mxcl.github.com/homebrew/" target="_blank" rel="noopener">MacPorts</a> 或者下载<a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">安装程序</a>。</li><li>Linux (Ubuntu, Debian)：<pre><code class="c">sudo apt-get install git-core</code></pre></li><li>Linux (Fedora, Red Hat, CentOS)：<pre><code class="c">sudo yum install git-core</code></pre>安装完成后，在bash中输入<code>git --version</code>验证是否安装成功。</li></ul><hr><h2 id="1-2-安装-Node-js"><a href="#1-2-安装-Node-js" class="headerlink" title="1.2 安装 Node.js"></a>1.2 安装 Node.js</h2><ul><li>Node.js 为大多数平台提供了官方的<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">安装程序</a>。对于中国大陆地区用户，可以前往<a href="https://npm.taobao.org/mirrors/node" target="_blank" rel="noopener">淘宝 Node.js 镜像</a>下载。</li><li>安装完成后，在bash中输入<code>node -v</code>验证是否安装成功。</li></ul><hr><h1 id="2-安装-Hexo"><a href="#2-安装-Hexo" class="headerlink" title="2. 安装 Hexo"></a>2. 安装 Hexo</h1><ul><li>安装必备应用程序后，即可使用<code>npm</code>（你配吗hahaha开个玩笑）来安装hexo<pre><code class="bash">$ npm install -g hexo-cli</code></pre></li></ul><hr><h1 id="3-使用-hexo"><a href="#3-使用-hexo" class="headerlink" title="3. 使用 hexo"></a>3. 使用 hexo</h1><p>安装后，可以使用两种方式执行hexo（推荐使用第二种哦:dog:~~~）：</p><ul><li><code>npx hexo &lt;命令&gt;</code></li><li>将 <strong>hexo 所在的目录下</strong>的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo &lt;命令&gt;</code>：<pre><code class="bash">echo &#39;PATH=&quot;$PATH:./node_modules/.bin&quot;&#39; &gt;&gt; ~/.profile</code></pre></li></ul><p><strong>hexo走起！</strong></p><h1 id="4-使用hexo搭建博客"><a href="#4-使用hexo搭建博客" class="headerlink" title="4. 使用hexo搭建博客"></a>4. 使用hexo搭建博客</h1><p>推荐参考文章：<a href="/2020/07/17/Hexo_hexo搭建个人博客/">hexo搭建个人博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>白嫖系列——xmind 8</title>
      <link href="/2020/04/04/%E7%99%BD%E5%AB%96%E7%B3%BB%E5%88%97_xmind%208/"/>
      <url>/2020/04/04/%E7%99%BD%E5%AB%96%E7%B3%BB%E5%88%97_xmind%208/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><blockquote><p>仅供学习交流使用，请支持正版，谢谢合作（白嫖，它不香么？）</p></blockquote><h1 id="1-在官网下载xmind最新的版本，安装软件"><a href="#1-在官网下载xmind最新的版本，安装软件" class="headerlink" title="1.在官网下载xmind最新的版本，安装软件"></a>1.在官网下载xmind最新的版本，安装软件</h1><p>官网地址：<a href="https://www.xmind.cn/download/xmind8" target="_blank" rel="noopener">https://www.xmind.cn/download/xmind8</a><br>本文用的是XMind 8 Update 9</p><h1 id="2-下载软件包"><a href="#2-下载软件包" class="headerlink" title="2.下载软件包"></a>2.下载软件包</h1><p>链接：<a href="https://pan.baidu.com/s/1TdcEU6RYYvAmpoMkpBj8MA" target="_blank" rel="noopener">https://pan.baidu.com/s/1TdcEU6RYYvAmpoMkpBj8MA</a><br>提取码：<code>3nbc</code> </p><h1 id="3-找到安装目录"><a href="#3-找到安装目录" class="headerlink" title="3. 找到安装目录"></a>3. 找到安装目录</h1><p>本文的是：<code>D:\Program Files (x86)\XMind</code><br>如果找不到，可以通过鼠标右键xmind图标–&gt;打开文件所在位置<br><img src="/img/article_img/%E7%99%BD%E5%AB%96%E7%B3%BB%E5%88%97/%E6%9F%A5%E6%89%BExmind%E5%AE%89%E8%A3%85%E4%BD%8D%E7%BD%AE.png" alt="查找xmind安装位置"></p><h1 id="4-打开我分享的文件"><a href="#4-打开我分享的文件" class="headerlink" title="4.打开我分享的文件"></a>4.打开我分享的文件</h1><p><img src="/img/article_img/%E7%99%BD%E5%AB%96%E7%B3%BB%E5%88%97/%E6%9F%A5%E6%89%BExmind%E7%A0%B4%E8%A7%A3%E6%96%87%E4%BB%B6.png" alt="查找xmind破解文件"><br>找到这个<code>.jar</code>的文件，复制到xmind的安装目录（第3步中的安装路径）</p><h1 id="5-修改xmind配置文件-xmind-ini"><a href="#5-修改xmind配置文件-xmind-ini" class="headerlink" title="5.修改xmind配置文件(xmind.ini)"></a>5.修改xmind配置文件(xmind.ini)</h1><p> 在安装目录下，找到xmind.ini文件，用记事本打开<br> 在最后<strong>添加一句代码</strong></p><pre><code class="bash">-javaagent:D:\Program Files(x86)\XMind\XMindCrack.jar</code></pre><p>并<strong>保存文件</strong><br><strong>注意：</strong> <code>-javaagent:</code>后面为<code>XMindCrack.jar</code>文件的路径，<strong>冒号要使用英文</strong></p><h1 id="6-打开安装后的xmind"><a href="#6-打开安装后的xmind" class="headerlink" title="6.打开安装后的xmind"></a>6.打开安装后的xmind</h1><p>在<strong>菜单栏</strong>找到 “帮助” –&gt; “序列号”，填写<strong>邮箱</strong>和<strong>序列号</strong><br>邮箱随便填写一个正确的格式，也可以填写你自己的邮箱<br>打开我分享的文件<code>xmind激活序列号.txt</code>，复制粘贴上去<br><img src="/img/article_img/%E7%99%BD%E5%AB%96%E7%B3%BB%E5%88%97/%E8%8E%B7%E5%8F%96xmind%E6%BF%80%E6%B4%BB%E5%BA%8F%E5%88%97%E5%8F%B7.png" alt="获取xmind激活序列号"></p><p><strong>激活成功<br>放肆的使用吧！</strong></p><p><strong>PS：</strong></p><p>仅供学习交流使用，任何人不得以商业盈利为目的，否则一切责任自己承担！</p>]]></content>
      
      
      <categories>
          
          <category> 白嫖系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 白嫖 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
