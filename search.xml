<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>蓝桥杯刷题_最大最小公倍数</title>
      <link href="/2020/09/09/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%88%B7%E9%A2%98-%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"/>
      <url>/2020/09/09/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%88%B7%E9%A2%98-%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="1-题目要求"><a href="#1-题目要求" class="headerlink" title="1. 题目要求"></a>1. 题目要求</h1><blockquote><p><strong>资源限制</strong><br>时间限制：1.0s   内存限制：256.0MB<br><strong>问题描述</strong><br>已知一个正整数N，问从1~N中任选出三个数，他们的最小公倍数最大可以为多少。</p><p><strong>输入格式</strong> </p><p>输入一个正整数N。</p><p><strong>输出格式</strong> </p><p>输出一个整数，表示你找到的最小公倍数。 </p><p><strong>样例输入</strong> </p><p>9 </p><p><strong>样例输出</strong> </p><p>504 </p><p><strong>数据规模与约定</strong> </p><p>1 &lt;= N &lt;= 10^6。</p></blockquote><h1 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h1><p>首先要知道什么是最小公倍数，以及怎么去求最小公倍数。</p><h2 id="2-1-最小公倍数的概念"><a href="#2-1-最小公倍数的概念" class="headerlink" title="2.1 最小公倍数的概念"></a>2.1 最小公倍数的概念</h2><p>公倍数(common multiple)指在两个或两个以上的自然数中，如果它们有相同的倍数，这些倍数就是它们的公倍数，其中除0以外最小的一个公倍数，叫做这几个数的<strong>最小公倍数</strong></p><h2 id="2-2-最小公倍数计算方法"><a href="#2-2-最小公倍数计算方法" class="headerlink" title="2.2 最小公倍数计算方法"></a>2.2 最小公倍数计算方法</h2><h3 id="2-2-1-分解质因数法"><a href="#2-2-1-分解质因数法" class="headerlink" title="2.2.1 分解质因数法"></a>2.2.1 分解质因数法</h3><p>先把这几个数的质因数写出来，最小公倍数等于它们所有的质因数的乘积（如果有几个质因数相同，则比较两数中哪个数有该质因数的个数较多，乘较多的次数）。</p><p>看看下面例子就知道如何去做了。<strong>求45和30的最小公倍数。</strong></p><blockquote><p>45=3*3*5</p><p>30=2*3*5</p></blockquote><p>45和30的不同质因数有一个<strong>2</strong>；共同的质因数有两个，分别是<strong>3</strong>、<strong>5</strong>。</p><p>接下来共同的质因数，45中出现了两个3，所以计算最小公倍数的时候乘两个3。共同质因数5在45和30都只出现了一次，计算最小公倍数的时候乘一个5就行了。</p><p>因此，45和30的最小公倍数为：2*3*3*5=90</p><h3 id="2-2-2-公式法"><a href="#2-2-2-公式法" class="headerlink" title="2.2.2 公式法"></a>2.2.2 公式法</h3><p>由于两个数的乘积等于这两个数的最大公约数与最小公倍数的积。即（a，b）×[a，b]=a×b。所以，求两个数的最小公倍数，就可以先求出它们的最大公约数，然后用上述公式求出它们的最小公倍数。</p><p>例如，<strong>求45和30的最小公倍数。</strong></p><p>45和30的最大公约数为15，两者之积为45*30=1350</p><p>然后用1350除以15，即1350÷15=90</p><h2 id="3-解题思路"><a href="#3-解题思路" class="headerlink" title="3. 解题思路"></a>3. 解题思路</h2><p>通过<strong>分解质因数法</strong>可以知道，最小公倍数的计算过程中，会因为有一些共同质因数，而导致最小公倍数小于两者的乘积，对于三个数的最小公倍数也是如此，因此我们要尽量避免这种因为共同质因数而带来的损失，就会使得我们得到的最小公倍数是局部最大的。因此只要我们找出三个最大的互质数之积，这题就解决了。</p><ol><li>由于连续的3个数中，如果是<strong>奇数 偶数 奇数</strong> ，那这三个数一定互质，证明方法也很简单。我们用反证法：</li></ol><blockquote><p>大前提是 n 为奇数，则 n-2、n-1、n这三个数满足奇数 偶数 奇数</p><p>我们先证明 n 和 n-2 这两个奇数互质。</p><p>假设 n 和 n-2 不互质，那么就存在一个公约数 p（p&gt;1，且为整数），使得 n = p * q （ q 为整数），n-2 = p * r（ r 为整数），</p><p>上两式相减，得到 2 = p * ( q - r )，由于 p 和 ( q - r )都是整数，故只能是 p = 2 （因为p&gt;1）、q-r = 1，</p><p>这样就与 n 和 n-2 为奇数矛盾了，因为是2的倍数，</p><p>因此， n 和 n-2 互质。</p><p>再证明相邻两个数 n 和 n-1 互质。</p><p>假设 n 和 n-1 不互质，那么那么就存在一个公约数 p（p&gt;1，且为整数），使得 n = p * q （ q 为整数），n-1 = p * r（ r 为整数），</p><p>上两式相减，得到 1 = p * ( q - r )，由于 p 和 ( q - r )都是整数，所以 p 和( q- r )都只能为1，</p><p>这与p &gt; 1矛盾，</p><p>因此， n 和 n-1 互质。</p><p>至此，三个连续的 奇数 偶数 奇数，n-2、n-1、n 一定两两互质。</p></blockquote><ol><li>连续的3个数中，还有可能是 <strong>偶数 奇数 偶数 **这种情况，但是这种情况会导致两个偶数都是2的倍数，最小公倍数损失一半，因此我们考虑将较小的偶数</strong>减1**变成奇数，这样就相当于是 n-3 、n-1、n 这三个数了。由上面知道 n-3 和 n-1 是连续的两个奇数，肯定互质，n-1和n是连续的两个数，也肯定互质，那么n和n-3是否一定互质呢？下面我们来探索一下。证明的思路和上面都是一样的。</li></ol><blockquote><p>大前提是n为偶数，，则 n-3、n-1、n这三个数满足奇数 奇数 偶数</p><p>我们下面要证明n和n-3是否互质，如果不互质，那要满足什么条件才能使得这两个数互质。</p><p>假设 n 和 n-3 不互质，那么就存在一个公约数 p（p&gt;1，且为整数），使得 n = p * q （ q 为整数），n-3 = p * r（ r 为整数），</p><p>上两式相减，得到 3 = p * ( q - r )，由于 p 和 ( q - r )都是整数，因此 p = 3 、q - r =1 或者 p = 1 ，q - r = 3，</p><p>到这里并不能找出矛盾，</p><p>因此我们添加一个条件，使之矛盾（楼下保安：去去去，你又来找茬。我：emmm…）</p><p>由于 p 是大于1的，观察两个结论中，有一个 p = 1的，所以我们就从这入手，添加一个条件使得能够得出该结论。所以，我们添加一个条件，排除掉p = 3 、q - r =1这种情况。很明显 p = 3 的时候，n 和 n - 3都是3的倍数。</p><p>因此我们添加的条件是： n 不为3的倍数（ n - 3 肯定也不为3的倍数了）</p><p>按照这个条件再严格证明一下。</p><p>假设 n 和 n-3 不互质，那么就存在一个公约数 p（p&gt;1，且为整数），使得 n = p * q （ q 为整数），n-3 = p * r（ r 为整数），</p><p>上两式相减，得到 3 = p * ( q - r )，由于 n 不为3的倍数，所以 p 一定不为3，因此只能是 p = 1，q - r = 3，</p><p>这与 p &gt; 1矛盾，</p><p>因此当 n 不为3的倍数，且 n 为奇数时，n 与 n-3 一定互质。</p><p>至此，矛盾大王实至名归。</p></blockquote><p>有了这两个最优解的可能性，这样的话本题目就很简单了。</p><p>伪代码如下：</p><pre><code class="c">输入Nresult = 1for n form N to 3        //逆序遍历    if n为奇数 且 result &lt; n * (n - 1) * (n - 2)        //情况一，奇数、偶数、奇数        result = n * (n - 1) * (n - 2)    if n为偶数 且 不能整除3 且 result &lt; n * (n - 1) * (n - 3) //情况一，奇数、偶数、奇数        result = n * (n - 1) * (n - 3)输出result</code></pre><p>python代码如下：</p><pre><code class="python">N = int(input())result = 1for n in range(N, 2, -1):    if n % 2 == 1 and result &lt; n * (n - 1) * (n - 2):        result = n * (n - 1) * (n - 2)    if n % 2 == 0 and n % 3 != 0 and result &lt; n * (n - 1) * (n - 3):        result = n * (n - 1) * (n - 3)print(result)</code></pre><p>如果有帮助，还望少侠留下你的赞！感谢支持。</p>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_vim命令</title>
      <link href="/2020/07/17/Linux_vim%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/07/17/Linux_vim%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><ul><li>vim是一个功能很完善的多模式编辑器，包括三种：普通模式、插入模式、命令行模式</li><li>以命令为中心，使用少量命令执行复杂的文本相关任务</li><li>内存占用很小</li><li>具有高度可配置性，并使用简单的文本文件来存储其配置</li></ul><blockquote><p>vim的操作非常多，本文只是列举了日常使用中常见的操作。</p></blockquote><h1 id="2-启动"><a href="#2-启动" class="headerlink" title="2. 启动"></a>2. 启动</h1><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">vim</td><td align="left">直接进入</td></tr><tr><td align="left">vim filename</td><td align="left">打开或新建文件filename</td></tr><tr><td align="left">vim +n filename</td><td align="left">打开文件filename，并将光标置于第n行首</td></tr><tr><td align="left">vim + filename</td><td align="left">打开文件filename，并将光标置于最后一行</td></tr><tr><td align="left">vim + /pattern filename</td><td align="left">打开文件filename，并将光标置于第一个于pattern匹配串的位置</td></tr><tr><td align="left">vim -r filename</td><td align="left">恢复上次异常退出的文件filename</td></tr><tr><td align="left">vim -y n filename</td><td align="left">打开文件filename，并将编辑窗口的大小设为n行</td></tr><tr><td align="left">vim -R filename</td><td align="left">以只读的方式打开文件filename，但可以强制保存</td></tr><tr><td align="left">vim -M filename</td><td align="left">以只读的方式打开文件filename，不可以强制保存</td></tr><tr><td align="left">vim -c com filename</td><td align="left">在打开文件filename前，先执行指定的命令com</td></tr></tbody></table><p>vim的启动方式很多，根据需求选择。</p><h2 id="3-基本使用"><a href="#3-基本使用" class="headerlink" title="3. 基本使用"></a>3. 基本使用</h2><p>vim编辑器有三个模式：普通模式、插入模式、命令行模式。</p><ul><li>普通模式：可以进入插入模式和命令行模式</li><li>插入模式：对文件进行修改</li><li>命令行模式：执行命令行命令</li></ul><p>三种模式的转换：</p><p><img src="/img/article_img/Linux/vim%E5%91%BD%E4%BB%A41.png#pic_center" alt="vim编辑器模式转换"></p><h2 id="3-1-文档操作"><a href="#3-1-文档操作" class="headerlink" title="3.1 文档操作"></a>3.1 文档操作</h2><table><thead><tr><th>*<em>命令 *</em></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>:q</td><td>退出vim编辑器，如果对当前文件的修改未保存，vim会警告</td></tr><tr><td>:w</td><td>保存文件</td></tr><tr><td>:!</td><td>强制执行</td></tr><tr><td>:q!</td><td>强制退出，不保存</td></tr><tr><td>:wq</td><td>保存并退出</td></tr><tr><td>ZZ</td><td>保存并退出</td></tr><tr><td>:x</td><td>保存并退出</td></tr><tr><td>:e file</td><td>关闭当前编辑的文件，并开启新的文件，如果对当前文件的修改未保存，vim会警告</td></tr><tr><td>:e! file</td><td>放弃对当前文件的修改，编辑新的文件</td></tr><tr><td>:e# 或 ctrl+^</td><td>回到刚才编辑的文件</td></tr><tr><td>f 或 ctrl+g</td><td>显示文档名，是否修改，和光标位置</td></tr><tr><td>:f filename</td><td>改变编辑的文件名，这时再保存相当于另存为</td></tr><tr><td>:saveas newfilename</td><td>另存为</td></tr><tr><td>:Sex</td><td>水平分割一个窗口，浏览文件系统</td></tr><tr><td>:Vex</td><td>垂直分割一个窗口，浏览文件系统</td></tr></tbody></table><h2 id="3-2-光标移动"><a href="#3-2-光标移动" class="headerlink" title="3.2 光标移动"></a>3.2 光标移动</h2><h3 id="3-2-1-基本移动"><a href="#3-2-1-基本移动" class="headerlink" title="3.2.1 基本移动"></a>3.2.1 基本移动</h3><p>下面的操作，可以搭配n使用，普通模式下输入<code>3l</code>，光标向右移动3个字符</p><table><thead><tr><th><strong>命令</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>h 或 退格(BackSpace)</td><td>光标<strong>左移</strong>一个字符</td></tr><tr><td>l 或 空格(Space)</td><td>光标<strong>右移</strong>一个字符</td></tr><tr><td>k</td><td>光标<strong>上移</strong>一行（段间）</td></tr><tr><td>j</td><td>光标<strong>下移</strong>一行（段间）</td></tr><tr><td>gk</td><td>光标<strong>上移</strong>一行（段内）</td></tr><tr><td>gj</td><td>光标<strong>下移</strong>一行（段内）</td></tr><tr><td>+ 或 回车(Enter)</td><td>光标移至<strong>下一行</strong>的第一个非空白字符</td></tr><tr><td>-</td><td>光标移至<strong>上一行</strong>的第一个非空白字符</td></tr><tr><td>w</td><td>光标移至<strong>下一个</strong>单词的开头</td></tr><tr><td>W</td><td>光标移至<strong>下一个</strong>单词的开头，忽略(跳过)标点</td></tr><tr><td>e</td><td>光标移至<strong>下一个</strong>单词的末尾</td></tr><tr><td>E</td><td>光标移至<strong>下一个</strong>单词的末尾，忽略(跳过)标点</td></tr><tr><td>b</td><td>光标移至<strong>上一个</strong>单词的开头</td></tr><tr><td>B</td><td>光标移至<strong>上一个</strong>单词的开头，忽略(跳过)标点</td></tr><tr><td>ge</td><td>光标移至<strong>上一个</strong>单词的末尾</td></tr><tr><td>gE</td><td>光标移至<strong>上一个</strong>单词的末尾，忽略(跳过)标点</td></tr><tr><td>(</td><td>光标移至<strong>上一句</strong></td></tr><tr><td>)</td><td>光标移至<strong>下一句</strong></td></tr><tr><td>{</td><td>光标移至<strong>上一段</strong></td></tr><tr><td>}</td><td>光标移至<strong>下一段</strong></td></tr><tr><td>fc</td><td>光标移至<strong>同一行</strong>的<strong>下一个</strong>字符c处，c是任意字符</td></tr><tr><td>Fc</td><td>光标移至<strong>同一行</strong>的<strong>上一个</strong>字符c处，c是任意字符</td></tr><tr><td>;</td><td>配合f &amp; t使用，<strong>重复一次</strong>上一次的光标移动</td></tr><tr><td>,</td><td>配合f &amp; t使用，<strong>反向重复一次</strong>上一次的光标移动</td></tr><tr><td>0</td><td>光标移至<strong>同一行</strong>的开头</td></tr><tr><td>^</td><td>光标移至<strong>同一行</strong>的第一个非空字符</td></tr><tr><td>$</td><td>光标移至<strong>同一行</strong>的末尾</td></tr><tr><td>nG</td><td>光标移至<strong>第n行</strong>的开头</td></tr><tr><td>n|</td><td>光标移至<strong>第n列</strong>的开头</td></tr><tr><td>gg</td><td>光标移至<strong>第一行</strong>的开头</td></tr><tr><td>G</td><td>光标移至<strong>最后一行</strong>的开头</td></tr></tbody></table><h3 id="3-2-2-翻屏"><a href="#3-2-2-翻屏" class="headerlink" title="3.2.2 翻屏"></a>3.2.2 翻屏</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>ctrl+f</td><td>下翻一屏</td></tr><tr><td>ctrl+b</td><td>上翻一屏</td></tr><tr><td>ctrl+d</td><td>下翻半屏</td></tr><tr><td>ctrl+u</td><td>上翻半屏</td></tr><tr><td>ctrl+e</td><td>向下滚动一行</td></tr><tr><td>ctrl+y</td><td>向上滚动一行</td></tr><tr><td>n%</td><td>到文件n%的位置</td></tr><tr><td>zz</td><td>将当前行移动到屏幕中央</td></tr><tr><td>zt</td><td>将当前行移动到屏幕顶端</td></tr><tr><td>zb</td><td>将当前行移动到屏幕底端</td></tr></tbody></table><h3 id="3-2-3-标记"><a href="#3-2-3-标记" class="headerlink" title="3.2.3 标记"></a>3.2.3 标记</h3><p>使用标记可以快速移动。到达标记后，可以用<code>Ctrl+o</code>返回原来的位置。 <code>Ctrl+o</code>和<code>Ctrl+i</code> 很像浏览器上的<code>前进</code>和<code>后退</code></p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>m{a-z}</td><td>标记光标所在位置，局部标记，只用于当前文件</td></tr><tr><td>m{A-Z}</td><td>标记光标所在位置，全局标记，标记之后，退出Vim， 重新启动，标记仍然有效</td></tr><tr><td>`{a-z}</td><td>移动到标记位置</td></tr><tr><td>‘{a-z}</td><td>移动到标记位置的行首</td></tr><tr><td>``</td><td>移动到上次编辑的位置</td></tr><tr><td>‘’</td><td>移动到上次编辑的位置所在的行</td></tr><tr><td>`”</td><td>移动到上次离开的地方</td></tr><tr><td>`.</td><td>移动到最后改动的地方</td></tr><tr><td>:marks</td><td>显示所有标记</td></tr><tr><td>:delmarks a b</td><td>删除标记a和b</td></tr><tr><td>:delmarks a c-f</td><td>删除标记a、c、d、e、f</td></tr><tr><td>:delmarks!</td><td>删除所有标记</td></tr><tr><td>:help mark-motions</td><td>查看mark帮助文档</td></tr></tbody></table><h2 id="3-3-插入文本"><a href="#3-3-插入文本" class="headerlink" title="3.3 插入文本"></a>3.3 插入文本</h2><p>小技巧：<code>ni</code>或<code>na</code>进入插入模式输入一个字符c，再按<code>Esc</code>退出插入模式，会自动补全成n个字符c，用于快速输入分割线</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>i</td><td>在<strong>光标前</strong>插入</td></tr><tr><td>I</td><td>在<strong>当前行第一个非空字符前</strong>插入</td></tr><tr><td>gI</td><td>在<strong>当前行第一列</strong>插入</td></tr><tr><td>a</td><td>在<strong>光标后</strong>插入</td></tr><tr><td>A</td><td>在<strong>当前行最后</strong>插入</td></tr><tr><td>o</td><td>在<strong>当前行后面</strong>新建一行插入</td></tr><tr><td>O</td><td>在<strong>当前行前面</strong>新建一行插入</td></tr></tbody></table><h2 id="3-4-复制、剪切、粘贴"><a href="#3-4-复制、剪切、粘贴" class="headerlink" title="3.4 复制、剪切、粘贴"></a>3.4 复制、剪切、粘贴</h2><h3 id="3-4-1-复制"><a href="#3-4-1-复制" class="headerlink" title="3.4.1 复制"></a>3.4.1 复制</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>y</td><td>复制在可视化模式下<strong>选中</strong>的文本</td></tr><tr><td>yy or Y</td><td>复制<strong>整行</strong>文本</td></tr><tr><td>y[n]w</td><td>复制<strong>n个词</strong>，默认为1</td></tr><tr><td>y[n]l</td><td>复制光标<strong>右边n个字符</strong>，默认为1</td></tr><tr><td>y[n]h</td><td>复制光标<strong>左边n个字符</strong>，默认为1</td></tr><tr><td>y0</td><td>从光标当前位置复制到<strong>行首</strong></td></tr><tr><td>y$</td><td>从光标当前位置复制到<strong>行尾</strong></td></tr><tr><td>:m,n co k</td><td>将<strong>m~n行</strong>的内容复制粘贴到k行之后(<strong>k+1行</strong>)</td></tr></tbody></table><h3 id="3-4-2-剪切"><a href="#3-4-2-剪切" class="headerlink" title="3.4.2 剪切"></a>3.4.2 剪切</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>d</td><td>剪切(删除)在可视化模式下<strong>选中</strong>的文本</td></tr><tr><td>d$ or D</td><td>剪切(删除)<strong>当前位置到行尾</strong>的内容</td></tr><tr><td>d[n]w</td><td>剪切(删除)<strong>n个词</strong>，默认为1</td></tr><tr><td>d[n]l</td><td>剪切(删除)光标<strong>右边n个字符</strong>，默认为1</td></tr><tr><td>d[n]h</td><td>剪切(删除)光标<strong>左边n个字符</strong>，默认为1</td></tr><tr><td>d0</td><td>剪切(删除)<strong>当前位置到行首</strong>的内容</td></tr><tr><td>[n]dd</td><td>剪切(删除)从<strong>当前位置向后的n行</strong>，默认为1</td></tr></tbody></table><h3 id="3-4-3-粘贴"><a href="#3-4-3-粘贴" class="headerlink" title="3.4.3 粘贴"></a>3.4.3 粘贴</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>p</td><td>在<strong>光标之后</strong>粘贴</td></tr><tr><td>P</td><td>在<strong>光标之前</strong>粘贴</td></tr></tbody></table><h2 id="3-5-查找和替换"><a href="#3-5-查找和替换" class="headerlink" title="3.5 查找和替换"></a>3.5 查找和替换</h2><h3 id="3-5-1-查找"><a href="#3-5-1-查找" class="headerlink" title="3.5.1 查找"></a>3.5.1 查找</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>/pattern</td><td>在<strong>光标后面</strong>的文本中查找包含pattern的内容</td></tr><tr><td>?pattern</td><td>在<strong>光标前面</strong>的文本中查找包含pattern的内容</td></tr><tr><td>n</td><td><strong>向后</strong>查找下一个</td></tr><tr><td>N</td><td><strong>向前</strong>查找下一个</td></tr></tbody></table><h3 id="3-5-2-替换"><a href="#3-5-2-替换" class="headerlink" title="3.5.2 替换"></a>3.5.2 替换</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>:s/old/new</td><td>用new替换<strong>当前行</strong>的第一个old</td></tr><tr><td>:s/old/new/g</td><td>用new替换<strong>当前行</strong>的所有old</td></tr><tr><td>:n1,n2 s/old/new/g</td><td>用new替换<strong>n1~n2行</strong>的所有old</td></tr><tr><td>:% s/old/new/g</td><td>用new替换<strong>当前文件所有的</strong>old</td></tr><tr><td>:% s/^/new/g</td><td>^表示行首，将行首替换为new，即在每一行的<strong>行首插入</strong>new</td></tr><tr><td>:% s/$/new/g</td><td>$表示行尾，将行尾替换为new，即在每一行的<strong>行尾插入</strong>new</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建个人博客</title>
      <link href="/2020/07/17/Hexo_hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/07/17/Hexo_hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><blockquote><p>hexo安装好之后，就可以开始搭建属于自己的博客了。如果没有安装hexo，参考文章：<a href="/2020/04/04/Hexo_hexo安装教程/">hexo安装教程</a></p></blockquote><h1 id="1-初始化项目"><a href="#1-初始化项目" class="headerlink" title="1. 初始化项目"></a>1. 初始化项目</h1><ul><li><p>为你的博客创建一个新的文件夹，该文件夹未来就是你博客放代码的地方，随便放哪都行。比如我的是：<code>D:\MyBolg</code>，创建命令如下：</p><pre><code>hexo init /d/mybolg            # Windows命令行不区分大小写</code></pre></li><li><p>初始化后，目录结构如下：</p><pre><code class="bash">.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes</code></pre><ol><li><p>_config.yml是总配置文件，里面可以修改很多东西，建议里面的所有设置都可以看看，根据里面的注释进行响应的改动，这里就不展开了。</p></li><li><p>themes目录下会自动生成一个默认的主题<code>landscape</code>，并且在source/_post目录下也自动生成了第一篇博客<code>hello-world</code></p></li></ol></li><li><p>启动本地预览服务命令：<code>hexo s</code>，然后在浏览器访问<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000</a>即可看到默认的博客内容</p><p><strong>小妙招：可以使用<code>hexo -h</code>查看hexo命令格式以及选项</strong></p></li></ul><h1 id="2-更换主题"><a href="#2-更换主题" class="headerlink" title="2. 更换主题"></a>2. 更换主题</h1><h2 id="2-1-下载地址"><a href="#2-1-下载地址" class="headerlink" title="2.1 下载地址"></a>2.1 下载地址</h2><ul><li>hexo主题下载地址：<a href="https://hexo.io/themes/#simple" target="_blank" rel="noopener"><a href="https://hexo.io/themes/#simple" target="_blank" rel="noopener">https://hexo.io/themes/#simple</a></a></li><li>选择一个你喜欢的主题，将其下载并保存到<code>themes/</code>目录下。比如下载的主题为xxx，其相对于博客主目录的路径为<code>themes/xxx</code></li></ul><h2 id="2-2-配置主题"><a href="#2-2-配置主题" class="headerlink" title="2.2 配置主题"></a>2.2 配置主题</h2><ul><li>将<code>_config.yml</code>中<code>theme: landscape</code>修改为<code>theme: xxx</code>，执行<code>hexo g</code>重新生成一下，g就表示generate选项。</li><li>如果出现一些莫名其妙的问题，可以先执行<code>hexo clean</code>来清理一下public的内容，然后再来重新生成和发布。</li></ul><h1 id="3-上传到github"><a href="#3-上传到github" class="headerlink" title="3. 上传到github"></a>3. 上传到github</h1><ul><li><p>修改_config.yml文件的deploy，直接修改一下yourname部分就可以了</p><pre><code class="bash">deploy:  type: git  repository: git@github.com:yourname/yourname.github.io.git  branch: master</code></pre></li><li><p>使用hexo deploy将本次改动的代码全部提交到github上</p></li></ul><h1 id="4-技巧"><a href="#4-技巧" class="headerlink" title="4. 技巧"></a>4. 技巧</h1><h2 id="4-1-快捷命令"><a href="#4-1-快捷命令" class="headerlink" title="4.1 快捷命令"></a>4.1 快捷命令</h2><ul><li><p>其实就通过 alias，触发一些命令的集合<br>在 <code>~/.bashrc</code> 文件中添加</p><pre><code>alias hs=&#39;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&#39;  #启动本地服务alias hd=&#39;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d&#39;  #部署博客</code></pre><p>甚至你也可以加入备份文章的命令，可以自由发挥。</p></li></ul><h2 id="4-2-博客备份（快捷命令升级版）"><a href="#4-2-博客备份（快捷命令升级版）" class="headerlink" title="4.2 博客备份（快捷命令升级版）"></a>4.2 博客备份（快捷命令升级版）</h2><ul><li>为了保证我们写的文章不丢失、快速迁移博客，都需要备份我们的 blog</li></ul><ol><li><p>博客根目录，执行 <code>git init</code> 创建 git 仓库</p></li><li><p>在 github（或其他托管平台、自建远程仓库等） 创建仓库并和本地仓库建立联系</p></li><li><p>在<code>~/.bashrc</code>文件中添加，使用<code>vim</code>命令，详情参见<a href="/2020/07/17/Linux_vim命令/">vim命令用法</a></p><pre><code>alias hs=&#39;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&#39;alias hd=&#39;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; git add . &amp;&amp; git commit -m &quot;update&quot; &amp;&amp; git push -f&#39;</code></pre></li></ol><ul><li>这样，我们在执行<code>hs</code>启动本地预览服务，当执行 <code>hd</code> 进行部署时，就一同将博客进行备份了</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux日常学习——pwd命令</title>
      <link href="/2020/06/12/Linux_pwd%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/06/12/Linux_pwd%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><blockquote><p>Linux中用 <code>pwd</code> 命令来查看”当前工作目录“的完整路径。 简单得说，每当你在终端进行操作时，你都会有一个当前工作目录。在不太确定当前位置时，就会使用<code>pwd</code>来判定当前目录在文件系统内的确切位置。</p></blockquote><h1 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2. 命令格式"></a>2. 命令格式</h1><pre><code class="bash">$ pwd [选项]</code></pre><h1 id="3-实用实例"><a href="#3-实用实例" class="headerlink" title="3. 实用实例"></a>3. 实用实例</h1><p><strong>例一：用 pwd 命令查看当前工作目录的完整路径</strong></p><pre><code class="bash">$ pwd/home/jiangle</code></pre><p><strong>例二：目录连接链接时，pwd -P 显示出实际路径，而非使用连接（link）路径；pwd显示的是连接路径</strong></p><pre><code class="bash">#目录为链接时，输出链接路径$ pwd -L#目录为链接时，输出物理路径$ pwd -P/home/jiangle</code></pre><p><strong>例三：当前目录被删除了，而pwd命令仍然显示那个目录</strong></p><pre><code class="bash">$ cd /opt/soft$ rm ../soft -rf$ pwd/opt/soft$ cd /bin/pwd/bin/pwd: couldnt find directory entry in “..” with matching i-node/home/jiangle</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux日常学习——cd命令</title>
      <link href="/2020/06/12/Linux_cd%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/06/12/Linux_cd%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><blockquote><p><code>cd</code> 命令是Linux中最基本的命令语句，其他的命令语句要进行操作，都是建立在使用 <code>cd</code> 命令上的。</p></blockquote><h1 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2. 命令格式"></a>2. 命令格式</h1><pre><code>$ cd [目录名]</code></pre><h1 id="3-范例"><a href="#3-范例" class="headerlink" title="3. 范例"></a>3. 范例</h1><p><strong>例一：进入系统根目录</strong></p><pre><code>$ cd /</code></pre><p><strong>例二：进入父级目录</strong></p><pre><code>$ cd ..$ cd ..//</code></pre><p><strong>例三：使用 cd 命令进入当前用户主目录</strong></p><pre><code>$ cd$ cd ~</code></pre><p><strong>例四：跳转到指定目录</strong></p><pre><code>$ cd /usr/bin</code></pre><p><strong>例五：返回进入此目录之前所在的目录</strong></p><pre><code>$ cd -</code></pre><p><strong>例六：把上个命令的参数作为cd参数使用</strong></p><pre><code>$ cd !$</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux日常学习——ls命令</title>
      <link href="/2020/06/12/Linux_ls%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/06/12/Linux_ls%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><blockquote><p><code>ls</code>是Linux下非常常用的命令，它是list的缩写，用于显示指定工作目录下的内容，以及文件和目录的权限等等。</p></blockquote><h1 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2. 命令格式"></a>2. 命令格式</h1><pre><code class="bash">$ ls \[选项] [目录名]</code></pre><h1 id="3-参数介绍"><a href="#3-参数介绍" class="headerlink" title="3. 参数介绍"></a>3. 参数介绍</h1><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-a,–all</td><td>列出目录下的所有文件，包括以 . 开头的隐含文件</td></tr><tr><td>-A</td><td>同-a，但不列出“.”(表示当前目录)和“..”(表示当前目录的父目录)。</td></tr><tr><td>-l</td><td>除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。</td></tr><tr><td>-t</td><td>将文件依建立时间之先后次序列出</td></tr><tr><td>-r, –reverse</td><td>依相反次序排列(原定依英文字母次序)</td></tr><tr><td>-R, –recursive</td><td>同时列出所有子目录层</td></tr><tr><td>-s,–size</td><td>以块大小为单位列出所有文件的大小</td></tr><tr><td>-S</td><td>根据文件大小排序</td></tr><tr><td>-F</td><td>在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“</td></tr></tbody></table><h1 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h1><ol><li>列出根目录（/）下的所有目录：</li></ol><pre><code class="bash"># ls /bin               dev   lib         media  net   root     srv  upload  wwwboot              etc   lib64       misc   opt   sbin     sys  usrhome  lost+found  mnt    proc  selinux  tmp  var</code></pre><ol start="2"><li>列出目前工作目录下所有名称是 s 开头的文件，越新的排越后面 :</li></ol><pre><code class="bash">ls -ltr s*</code></pre><ol start="3"><li>将 /bin 目录以下所有目录及文件详细资料列出 :</li></ol><pre><code class="bash">ls -lR /bin</code></pre><ol start="4"><li>列出目前工作目录下所有文件及目录；目录于名称后加 “/“, 可执行档于名称后加 “*” :</li></ol><pre><code class="bash">ls -AF</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux日常学习——awk命令</title>
      <link href="/2020/06/12/Linux_awk%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/06/12/Linux_awk%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><ul><li><code>awk</code>是一种编程语言（解释性语言，不需要编译），用于<strong>数据截取和报告的工具</strong></li><li><code>awk</code>自动搜索输入的文件，并把每个输入行切分成多个字段（字段：根据分隔符分割成的单元）</li><li>擅长<strong>处理数据库和表型数据</strong>。适合编写短小一次性程序</li><li><code>centos</code>默认的<code>awk</code>使用的是<code>gawk</code>，系统将<code>awk</code>通过软链接来指向<code>gawk</code></li><li>可以使用新的内置函数和变量</li><li>在缺省的情况下，它使用扩展的正则表达式</li><li><code>awk</code>不需要声明变量的数据类型，它内置字符串类型和数值类型</li></ul><h1 id="二、命令格式"><a href="#二、命令格式" class="headerlink" title="二、命令格式"></a>二、命令格式</h1><pre><code>awk [OPTIONS] [--] program filename_list</code></pre><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-f program -file</td><td>指定包含了awk命令的文件，不是从命令行参数中去读取 可以通过-f选项指定多个包含awk命令文件</td></tr><tr><td>-F ‘fs’ –field -separator</td><td>指定分隔符即为定义FS变量对应的值</td></tr><tr><td>-v var=val</td><td>在程序开始之前，将val这个值赋给var这个变量</td></tr><tr><td>-d[file]</td><td>将全局变量的类型和最终值排序，并将排序好后的结果打印输出到文件中</td></tr><tr><td>-V</td><td>显示awk的版本</td></tr></tbody></table><h1 id="三、使用方法及范例"><a href="#三、使用方法及范例" class="headerlink" title="三、使用方法及范例"></a>三、使用方法及范例</h1><h2 id="3-1-awk的核心"><a href="#3-1-awk的核心" class="headerlink" title="3.1 awk的核心"></a>3.1 awk的核心</h2><ul><li><strong>PROGRAM——‘pattern{action}’</strong></li></ul><h2 id="3-2-关于pattern-action-的说明："><a href="#3-2-关于pattern-action-的说明：" class="headerlink" title="3.2 关于pattern { action }的说明："></a>3.2 关于pattern { action }的说明：</h2><ul><li><code>pattern</code>与<code>action</code>并非同时存在，可以省略其中一个</li><li>如果<code>action</code>被省略，默认动作是将每个匹配的行输出</li><li>如果<code>pattern</code>被省略，对于每行都会执行动作</li></ul><h3 id="awk基本操作流程："><a href="#awk基本操作流程：" class="headerlink" title="awk基本操作流程："></a>awk基本操作流程：</h3><ol><li>从输入流中读取一行内容，然后使用<code>pattern{action}</code>去处理</li><li>对读取的行进行扫描搜索，搜索行中是否有内容被pattern匹配</li><li>如果行被<code>pattern</code>匹配成功，则执行动作<code>{action}</code>；如果行中内容不被<code>pattern</code>匹配，则不执行</li><li>继续从输入流中读取新的一行，重复上述几个步骤</li></ol><h4 id="例一：简单理解awk"><a href="#例一：简单理解awk" class="headerlink" title="例一：简单理解awk"></a>例一：简单理解awk</h4><p>问题描述：</p><ul><li><code>file1</code>文件第一列为员工名字，第二列为时薪，第三列为工作时长</li><li>打印输出员工的名字、时薪和工作时长</li></ul><p>执行命令：</p><pre><code class="bash">[root@CentOS7 commands]# cat file1Sam    50    8Jiangle    55    9Tom    40    6Tim    60    9[root@CentOS7 commands]# awk &#39;{print $1,$2,$3}&#39; file1Sam    50    8Jiangle    55    9Tom    40    6Tim    60    9</code></pre><p><strong>说明：</strong></p><ul><li><code>awk</code>命令后面的程序用<strong>单引号</strong>引起来，单引号后面的部分为输入文件</li><li>单引号中包围的内容是一个<code>awk</code>程序（program），即模式-动作语句（pattern-action）</li></ul><h2 id="3-3-pattern详细说明"><a href="#3-3-pattern详细说明" class="headerlink" title="3.3 pattern详细说明"></a>3.3 pattern详细说明</h2><ul><li><code>pattern</code>，即模式，是决定<code>awk</code>程序中定义的动作action是否能够被执行的关键</li><li><code>pattern</code>支持的规则：正则表达式，字符串与数字比较，流程控制语句</li></ul><h4 id="例二：pattern——控制输出条件1"><a href="#例二：pattern——控制输出条件1" class="headerlink" title="例二：pattern——控制输出条件1"></a>例二：pattern——控制输出条件1</h4><p>问题描述：</p><ul><li><code>file1</code>文件第一列为员工名字，第二列为时薪，第三列为工作时长</li><li>打印输出时薪大于等于50的员工名字和总薪资</li></ul><p>执行命令：</p><pre><code class="bash">[root@CentOS7 commands]# cat file1Sam    50    8Jiangle    55    9Tom    40    6Tim    60    9[root@CentOS7 commands]# awk &#39;$2&gt;=50 {print $1,$2*$3}&#39; file1Sam 400Jiangle 495Tim 540</code></pre><p><strong>说明：</strong></p><ul><li>其中模式<code>pattern</code>为<code>&#39;$2&gt;=50&#39;</code>，表示扫描每一个输入的行，如果第二列大于0，则执行动作<code>action</code>，否则不执行<code>action</code></li><li>动作<code>action</code>为<code>&#39;{ print $1,$2*$3 }&#39;</code>,模式匹配成功后执行的对应动作，该动作用于打印输出第一个字段和第二、三字段的乘积</li></ul><h3 id="模式表示方式汇总："><a href="#模式表示方式汇总：" class="headerlink" title="模式表示方式汇总："></a>模式表示方式汇总：</h3><table><thead><tr><th>模式</th><th align="center">说明</th></tr></thead><tbody><tr><td><code>/regexp/</code></td><td align="center">正则之字符串匹配模式/regexp/（拓展的正则表达式）<br />例如：expression ~ /regexpr/表示当前输入行包含能被regexpr匹配的子字符串时，该模式被匹配</td></tr><tr><td><code>relational expression</code></td><td align="center">当表达式拥有一个数值形式的值，运算符要求一个字符串值，则awk会将该数值自动转换成字符串<br />当表达式拥有一个字符串形式的值，运算符要求一个数值，则awk会将该字符串值自动转换成数值<br />关于表达式真与假的说明：如果一个表达式，对当前述入行的求值结果非零或不为空，那么该行就被匹配<br />如果比较字符串，比较时是逐字符依赖ASCII字符表比较</td></tr><tr><td><code>pattern 1 &amp;&amp; pattern2</code></td><td align="center">只有当pattern1和pattern2都匹配了，才会执行action</td></tr><tr><td>`pattern1</td><td align="center"></td></tr></tbody></table><h3 id="比较运算符汇总"><a href="#比较运算符汇总" class="headerlink" title="比较运算符汇总"></a>比较运算符汇总</h3><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>==</td><td>等于</td></tr><tr><td>!=</td><td>不等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>~</td><td>匹配</td></tr><tr><td>!~</td><td>不匹配</td></tr></tbody></table><h3 id="表达式运算符汇总（也可以用在action）"><a href="#表达式运算符汇总（也可以用在action）" class="headerlink" title="表达式运算符汇总（也可以用在action）"></a>表达式运算符汇总（也可以用在action）</h3><table><thead><tr><th>操作</th><th>运算符</th><th>举例</th></tr></thead><tbody><tr><td>赋值</td><td>=、+=、-=、*=、/=、^=</td><td><code>sum+=i</code>，即<code>sum=sum+i</code></td></tr><tr><td>条件表达式</td><td>？:</td><td><code>x?y:z</code>，若x为真则为y，否则为z</td></tr><tr><td>逻辑或</td><td>||</td><td><code>x||y</code>，x或y为真，则表达式为真</td></tr><tr><td>逻辑与</td><td>&amp;&amp;</td><td><code>x&amp;&amp;y</code>，x与y为真，则表达式为真</td></tr><tr><td>数组成员</td><td>in</td><td><code>i in a</code>，i在a中</td></tr><tr><td>字段</td><td>$</td><td><code>$1</code> 表示输入行的第一个字段</td></tr><tr><td>组合</td><td>(  )</td><td><code>$(2+1)</code> 表示第三个字段</td></tr><tr><td>匹配<br />不匹配</td><td>~<br />!~</td><td></td></tr><tr><td>自增<br />自减</td><td>++<br />–</td><td></td></tr></tbody></table><h4 id="例三：pattern——控制输出条件2"><a href="#例三：pattern——控制输出条件2" class="headerlink" title="例三：pattern——控制输出条件2"></a>例三：pattern——控制输出条件2</h4><p>问题描述：</p><ul><li>打印输出<code>file2</code>第一和二个字段都为数字或第三和四个字段都为字母的行</li></ul><p>执行命令：</p><pre><code class="bash">[root@CentOS7 commands]# cat file21 2 3 41 2 a ba 1 4 31 a 2 b[root@CentOS7 commands]# awk &#39;($1~/[0-9]/ &amp;&amp; $2~/[0-9]/)||($3~/[a-zA-Z]/ &amp;&amp; $4~/[a-zA-Z]/)&#39; file21 2 3 41 2 a b</code></pre><p><strong>说明：</strong></p><ul><li><code>$1~/[0-9]/</code>表示匹配第一列中包含数字0-9，其中的<code>pattern</code>为[0-9]</li><li><code>$3~/[a-zA-Z]/</code>表示匹配任意大小写字母</li></ul><h2 id="3-4-action详细说明"><a href="#3-4-action详细说明" class="headerlink" title="3.4 action详细说明"></a>3.4 action详细说明</h2><h3 id="关键字和变量"><a href="#关键字和变量" class="headerlink" title="关键字和变量"></a>关键字和变量</h3><ul><li><strong>关键字</strong></li></ul><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td><code>BEGIN</code></td><td>放在程序开头，当<code>awk</code>从输入流中读取数据之前，<code>BEGIN</code>语句开始执行（初始化），可以执行多个<code>BEGIN</code></td></tr><tr><td><code>END</code></td><td>放在程序末尾，当所有输入流被读取完毕，<code>END</code>语句开始执行（扫尾），可以执行多个<code>END</code></td></tr></tbody></table><ul><li><strong>内建变量</strong></li></ul><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td><code>$n</code></td><td>当前记录的第n个字段，字段间由FS分隔</td></tr><tr><td><code>$0</code></td><td>完整的输入记录</td></tr><tr><td><code>FS</code></td><td>Field Separator，表示字符分隔符，即读取输入流时，以FS作为字段分隔的依据，默认为空格符</td></tr><tr><td><code>RS</code></td><td>Record Separator，表示记录分隔符，即读取输入流时，以RS作为记录分隔的依据，默认是一个换行符</td></tr><tr><td><code>OFS</code></td><td>Output Field Separator，表示输出字段分隔符，默认为空格符</td></tr><tr><td><code>ORS</code></td><td>Output Record Separator，表示输出记录分隔符，默认为换行符</td></tr><tr><td><code>NF</code></td><td>Number of Field，表示每一行的字段数目</td></tr><tr><td><code>NR</code></td><td>Number of Row，记录读取的行的行号</td></tr><tr><td><code>IGNORECASE</code></td><td>IGNORECASE如果为真，则进行忽略大小写的匹配</td></tr></tbody></table><h4 id="例四：action——控制语句输出1"><a href="#例四：action——控制语句输出1" class="headerlink" title="例四：action——控制语句输出1"></a>例四：action——控制语句输出1</h4><p>问题描述：</p><ul><li><code>file1</code>文件第一列为员工名字，第二列为时薪，第三列为工作时长</li><li>打印输出每一个员工名字和总薪资，添加一个表头说明，中间用”:”隔开</li></ul><p>执行命令：</p><pre><code class="bash">[root@CentOS7 commands]# cat file1Sam    50    8Jiangle    55    9Tom    40    6Tim    60    9[root@CentOS7 commands]# awk &#39;BEGIN{OFS=&quot;:&quot;;ORS=&quot;\n\n&quot;} BEGIN{print &quot;name:total_salary&quot;} {print $1,$2*$3}&#39; file1name:total_salarySam:400Jiangle:495Tom:240Tim:540</code></pre><p><strong>说明：</strong></p><ul><li>第一个<code>BEGIN</code>语句是控制输出字段分隔符<code>OFS</code>和输出记录分隔符<code>ORS</code></li><li>第二个<code>BEGIN</code>语句是输出字符串<code>&quot;name:total_salary&quot;</code></li><li>执行完两个BEGIN后，<code>awk</code>再从输入流中读取处理数据</li><li>注意：对变量<code>FS</code>、<code>OFS</code>和<code>ORS</code>赋值时，需要使用双引号，不能没有引号或使用单引号</li></ul><h3 id="格式化输出语句"><a href="#格式化输出语句" class="headerlink" title="格式化输出语句"></a>格式化输出语句</h3><p><code>action</code>的格式化输出语句通过<code>printf</code>实现，在<code>print</code>语句中，多个变量之间使用逗号作为分隔符，对变量进行分隔</p><ul><li><strong>printf语法格式：</strong><code>printf(format，expression1，expression2…)</code></li><li>参数<code>format</code>包含“%”、对齐方式、格式控制字符、字符串最大宽度</li></ul><h3 id="printf格式控制字符"><a href="#printf格式控制字符" class="headerlink" title="printf格式控制字符"></a>printf格式控制字符</h3><table><thead><tr><th>格式字符</th><th>说明</th></tr></thead><tbody><tr><td><code>-</code></td><td>左对齐修饰符，默认为右对齐</td></tr><tr><td><code>#</code></td><td>显示8 进制整数时在前面加个0<br/>显示16 进制整数时在前面加0x</td></tr><tr><td><code>+</code></td><td>显示使用d 、e 、f 和g 转换的整数时，加上正负号±</td></tr><tr><td><code>0</code></td><td>用0而不是空白符来填充所显示的值，即用字符’0’填充</td></tr><tr><td><code>%c</code></td><td>表示一个ASCII字符</td></tr><tr><td><code>%s</code></td><td>表示一个字符串</td></tr><tr><td><code>%d</code></td><td>表示一个十进制整数</td></tr><tr><td><code>%u</code></td><td>表示一个无符号的十进制数</td></tr><tr><td><code>%x</code></td><td>表示一个十六进制数</td></tr><tr><td><code>%o</code></td><td>表示一个八进制数</td></tr><tr><td><code>%f</code></td><td>表示一个浮点数</td></tr><tr><td><code>%e</code></td><td>用科学计数法(e 记数法)，表示一个浮点数</td></tr><tr><td><code>%g</code></td><td>选择e或f中较短的一种形式</td></tr></tbody></table><p>上面差不多就是<code>printf</code>的常用格式输出了，下面是一些常用的复合。就是啊，附和！！！</p><p><img src="https://img-blog.csdnimg.cn/20200612215225198.jpg#pic_center" alt="hahaa"></p><table><thead><tr><th>复合格式字符</th><th>说明</th></tr></thead><tbody><tr><td><code>%10d</code></td><td>十进制数占10列</td></tr><tr><td><code>%010d</code></td><td>十进制数占10列，前面用字符’0’填充</td></tr><tr><td><code>%+10d</code></td><td>十进制数占10列，包含数值的符号(±)</td></tr><tr><td><code>%#10x</code></td><td>十六进制数占10列，显示前缀0x</td></tr><tr><td><code>%-10.3f</code></td><td>浮点数左对齐占10列，保留3位小数</td></tr><tr><td><code>%0+10.3f</code></td><td>浮点数右对齐占10列，保留3位小数，显示符号，左补齐填充字符’0’</td></tr><tr><td><code>%10s</code></td><td>字符串右对齐，占10列</td></tr><tr><td><code>%-10s</code></td><td>字符串左对齐，占10列</td></tr></tbody></table><h4 id="例五：action——控制语句输出2"><a href="#例五：action——控制语句输出2" class="headerlink" title="例五：action——控制语句输出2"></a>例五：action——控制语句输出2</h4><p>问题描述：</p><ul><li><code>file1</code>文件第一列为员工名字，第二列为时薪，第三列为工作时长</li><li>打印输出每一个员工编号（所在行数即为编号）、名字和总薪资；员工编号左对齐占5列，名字右对齐占10列，总薪资占10列右对齐保留两位小数</li></ul><p>执行命令：</p><pre><code class="bash">[root@CentOS7 commands]# cat file1Sam    50    8Jiangle    55    9Tom    40    6Tim    60    9[root@CentOS7 commands]# awk &#39;BEGIN{printf &quot;%-5s%10s%10s\n&quot;,&quot;ID&quot;,&quot;NAME&quot;,&quot;SALARY&quot;}{printf(&quot;%-5d%10s%10.2f\n&quot;,NR,$1,$(NF-1)*$NF))}&#39; file1ID         NAME    SALARY1           Sam    400.002       Jiangle    495.003           Tom    240.004           Tim    540.00</code></pre><p><strong>说明：</strong></p><ul><li><code>NF</code>表示当前行的字段数（列数），<code>$NF</code>表示当前行的最后一个字段值</li><li>这里的<code>$(NF-1)*$NF</code>与<code>$2*$3</code>相同</li><li><code>printf</code>不会自动换行，需要添加换行符<code>&quot;\n&quot;</code>才能换行</li></ul><h1 id="四、awk进阶"><a href="#四、awk进阶" class="headerlink" title="四、awk进阶"></a>四、awk进阶</h1><h2 id="4-1-输出重定向"><a href="#4-1-输出重定向" class="headerlink" title="4.1 输出重定向"></a>4.1 输出重定向</h2><h3 id="4-1-2-输出重定向到文件"><a href="#4-1-2-输出重定向到文件" class="headerlink" title="4.1.2 输出重定向到文件"></a>4.1.2 输出重定向到文件</h3><ul><li>使用<code>&gt;&gt;</code>重定向，不清空文件内容，将内容追加到文件尾部</li><li>使用<code>&gt;</code>重定向，清空文件内容，再把内容写入文件</li></ul><h4 id="例六：输出重定向到文件"><a href="#例六：输出重定向到文件" class="headerlink" title="例六：输出重定向到文件"></a>例六：输出重定向到文件</h4><p>问题描述：</p><ul><li><code>file1</code>文件第一列为员工名字，第二列为时薪，第三列为工作时长</li><li>将时薪大于等于50的员工的信息保存到<code>new_file1</code>中</li></ul><p>执行命令：</p><pre><code class="bash">[root@CentOS7 commands]# cat file1Sam    50    8Jiangle    55    9Tom    40    6Tim    60    9[root@CentOS7 commands]# awk &#39;$2&gt;=50 {print $0 &gt; &quot;new_file1&quot;}&#39; file1[root@CentOS7 commands]# cat new_file1 Sam    50    8Jiangle    55    9Tim    60    9</code></pre><p><strong>说明：</strong></p><ul><li>重定向时，文件名必须要用<strong>双引号</strong>引起来，否则会被当作一个未初始化的变量</li><li><code>&gt;</code>重定向时，会覆盖目标文件的内容</li></ul><h3 id="4-1-2-输出重定向到管道"><a href="#4-1-2-输出重定向到管道" class="headerlink" title="4.1.2 输出重定向到管道"></a>4.1.2 输出重定向到管道</h3><ul><li>使用管道命令<code>|</code>进行数据的处理</li></ul><h4 id="例七：输出重定向到管道"><a href="#例七：输出重定向到管道" class="headerlink" title="例七：输出重定向到管道"></a>例七：输出重定向到管道</h4><p>问题描述：</p><ul><li><code>file1</code>文件第一列为员工名字，第二列为时薪，第三列为工作时长</li><li>按照总薪资降序进行排序，名字占10列左对齐，时薪占10列左对齐，工作时长占10列左对齐，总薪资占10列左对齐</li></ul><p>执行命令：</p><pre><code class="bash">[root@CentOS7 commands]# cat file1Sam    50    8Jiangle    55    9Tom    40    6Tim    60    9[root@CentOS7 commands]# awk &#39;{printf(&quot;%-10s%-10d%-10d%-10d\n&quot;,$1,$2,$3,$2*$3) | &quot;sort -nrk 4 &quot;}&#39; file1Tim       60        9         540       Jiangle   55        9         495       Sam       50        8         400       Tom       40        6         240       </code></pre><p><strong>说明：</strong></p><ul><li>语句<code>{printf(...) | &quot;sort...&quot;}</code>中的<code>sort</code>必须用<strong>双引号</strong>引起来</li><li><code>sort</code>中<code>-n</code>表示按照字符串的数值顺序比较；<code>-r</code>表示逆序比较，默认为升序；<code>-k 4</code> 表示以第4个字段（第4列）为关键字进行比较</li><li>也可以将<code>awk</code>的格式化输出通过管道传递给<code>sort</code>命令，也能实现排序并格式化输出，等价命令为：<code>awk &#39;{printf(&quot;%-10s%-10d%-10d%-10d\n&quot;,$1,$2,$3,$2*$3)}&#39; file1 | sort -nrk 4</code></li></ul><h2 id="4-2-流程控制"><a href="#4-2-流程控制" class="headerlink" title="4.2 流程控制"></a>4.2 流程控制</h2><p>流程控制语句中，<code>if-else</code>用于决策，<code>while</code>、<code>for</code>、<code>do whlie</code>用于循环，<code>break</code>、<code>continue</code>用于控制循环</p><h3 id="4-2-1-if-else语句"><a href="#4-2-1-if-else语句" class="headerlink" title="4.2.1 if-else语句"></a>4.2.1 if-else语句</h3><h4 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h4><pre><code class="bash">{    if （expression）        statements    else        statements}</code></pre><p>或者</p><pre><code class="bash">{if (expression) statements;else statements}    </code></pre><h4 id="例八：简单使用if-else语句"><a href="#例八：简单使用if-else语句" class="headerlink" title="例八：简单使用if-else语句"></a>例八：简单使用if-else语句</h4><pre><code class="bash">[root@CentOS7 commands]# cat file1Sam    50    8Jiangle    55    9Tom    40    6Tim    60    9[root@CentOS7 commands]# cat if.awk #!/bin/bash{    if($2&gt;=50)        printf(&quot;%s has a good salary!\n&quot;,$1)        else            printf(&quot;%s need to change a job!\n&quot;,$1)}[root@CentOS7 commands]# awk -f if.awk file1Sam has a good salary!Jiangle has a good salary!Tom need to change a job!Tim has a good salary!</code></pre><p> <strong>说明：</strong></p><ul><li><code>awk -f</code> 可以指定文件作为<code>pattern{action}</code>，上述例子并未指定<code>pattern</code></li><li>从上述例子可以看出，时薪小于50的，就可以换工作了（hahaa，偶尔皮一下🐶）</li></ul><h3 id="4-2-2-while语句"><a href="#4-2-2-while语句" class="headerlink" title="4.2.2 while语句"></a>4.2.2 while语句</h3><h4 id="语法结构-1"><a href="#语法结构-1" class="headerlink" title="语法结构"></a>语法结构</h4><pre><code class="bash">{    while (expression)    {    statement1    statement2    ...    }}</code></pre><p>或者</p><pre><code class="bash">{while (expression){statement1;statement2;...}}</code></pre><h4 id="例九：简单的使用while语句"><a href="#例九：简单的使用while语句" class="headerlink" title="例九：简单的使用while语句"></a>例九：简单的使用while语句</h4><p>问题描述：</p><ul><li>将<code>data</code>文件中的数按行求和并输出</li></ul><p>执行命令：</p><pre><code class="bash">[root@CentOS7 commands]# cat data 1 2 3 45 6 7 8 96 6 6 6 6 610 20 30 40 50 [root@CentOS7 commands]# cat while.awk #!/bin/bash{    i=1    sum=0    while(i&lt;=NF)    {        sum+=$i        i++    }    printf(&quot;Line %d, sum is %d\n&quot;,NR,sum)}[root@CentOS7 commands]# awk -f while.awk dataLine 1, sum is 10Line 2, sum is 35Line 3, sum is 36Line 4, sum is 150</code></pre><p><strong>说明：</strong></p><ul><li>每从输入流读取一行，<code>while</code>循环就会被执行</li><li>当<code>expression</code>的值为真时，进入<code>while</code>循环</li></ul><h3 id="4-2-3-for语句"><a href="#4-2-3-for语句" class="headerlink" title="4.2.3 for语句"></a>4.2.3 for语句</h3><h4 id="语法结构-2"><a href="#语法结构-2" class="headerlink" title="语法结构"></a>语法结构</h4><pre><code class="bash">{    for(expresion1;expression2;expression3)    {        statement1        statement2    }}</code></pre><p>或者</p><pre><code class="bash">{ for(expresion1;expression2;expression3){statement1;statement2;...}}</code></pre><ul><li><code>expression1</code>：进入<code>for</code>循环之前执行一次该语句。一般用于对变量的初始化</li><li><code>expression2</code>：每执行一次循环后，都会执行一次该语句，如果结果为真，则继续循环，反之退出循环。一般用于循环的条件判断</li><li><code>expression3</code>：每执行一次循环后，都会执行一次该语句。一般用于做变量变化</li></ul><h4 id="例十：简单的使用for语句"><a href="#例十：简单的使用for语句" class="headerlink" title="例十：简单的使用for语句"></a>例十：简单的使用for语句</h4><p>问题描述：</p><ul><li>将<code>data</code>文件中的数按行求和并输出</li></ul><p>执行命令：</p><pre><code>[root@CentOS7 commands]# cat data 1 2 3 45 6 7 8 96 6 6 6 6 610 20 30 40 50 [root@CentOS7 commands]# cat while.awk #!/bin/bash{    sum=0    for(i=1;i&lt;=NF;i++)        sum+=$i    printf(&quot;Line %d, sum is %d\n&quot;,NR,sum)}[root@CentOS7 commands]# awk -f for.awk dataLine 1, sum is 10Line 2, sum is 35Line 3, sum is 36Line 4, sum is 150</code></pre><p>循环语句里面也可以使用<code>break</code>、<code>continue</code>语句，具体的使用这里就不再赘述了。</p><p>我的🐴🦆，8k+字！！！第一次总结这么多，累辽~~</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux日常学习——Shell函数</title>
      <link href="/2020/06/02/Linux_Shell%E5%87%BD%E6%95%B0/"/>
      <url>/2020/06/02/Linux_Shell%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h1 id="1-Shell函数的好处"><a href="#1-Shell函数的好处" class="headerlink" title="1. Shell函数的好处"></a>1. Shell函数的好处</h1><p><strong>1. 简化程序代码，实现代码重用</strong></p><ul><li>实现一次定义多次调用。如：is_root_user（）函数可 以由不同的shell脚本重复使用。 </li></ul><p><strong>2. 实现结构化编程</strong> </p><ul><li>使脚本内容更加简洁，增强程序的易读性</li></ul><p><strong>3. 提高执行效率</strong></p><ul><li>将常用的功能定义为多个函数并将其保存在一个文件中，类似其他语言的“模块”文件</li><li>在 <code>~/bashrc</code> 里或命令行上使用 <code>source</code> 命令调用这个文件 </li><li>此文件中定义的多个函数一次性地调入内存，从而加快运行速度</li></ul><h1 id="2-函数的定义和调用"><a href="#2-函数的定义和调用" class="headerlink" title="2. 函数的定义和调用"></a>2. 函数的定义和调用</h1><p><strong>1. 函数定义</strong></p><blockquote><p>function 函数名 { commands }</p><p>函数名 () { commands }</p></blockquote><p><strong>2. 函数调用</strong></p><p>只需输入函数名即可调用函数，函数必须在调用之前定义</p><blockquote><p>函数名<br>函数名 参数1  参数2  …</p></blockquote><h1 id="3-函数的存储和显示"><a href="#3-函数的存储和显示" class="headerlink" title="3. 函数的存储和显示"></a>3. 函数的存储和显示</h1><p><strong>1. 函数的存储</strong></p><ul><li><p>函数和调用它的主程序保存在同一个文件中 </p><p>函数的定义必须出现在调用之前</p></li><li><p>函数和调用它的主程序保存在不同的文件中</p><p>保存函数的文件必须先使用 <code>source</code> 命令执行，之后才 能调用其中的函数</p></li></ul><p><strong>2. 函数的显示</strong> </p><ul><li><p>显示当前Shell可见的所有函数名 </p><pre><code class="bash">$ declare -F</code></pre></li><li><p>显示当前Shell可见的所有（指定）的函数定义 </p><pre><code class="bash">$ declare -f $ declare -f  &lt;functionName&gt; </code></pre></li></ul><h1 id="4-函数的调用举例"><a href="#4-函数的调用举例" class="headerlink" title="4. 函数的调用举例"></a>4. 函数的调用举例</h1><ul><li><strong>函数和调用它的主程序保存在同一个文件中</strong> </li></ul><pre><code class="bash">#!/bin/bash ## filename: function-1.sh ### User define Function (UDF) ### sql_bak () { echo &quot;Running mysqldump tool...&quot;; } sync_bak () { echo &quot;Running rsync tool...&quot;; } git_bak () { echo &quot;Running gistore tool...&quot;; } tar_bak () { echo &quot;Running tar tool...&quot;; } ### Main script starts here ### PS3=&quot;Please choose a backup tools : &quot; select s in mysqldump rsync gistore tar quit ; do     case $REPLY in        1) sql_bak  ;;         2) sync_bak ;;         3) git_bak  ;;         4) tar_bak  ;;         5) exit     ;;     esac done</code></pre><ul><li><strong>函数和调用它的主程序保存在不同的文件</strong></li></ul><pre><code class="bash">#!/bin/bash ## filename: function-2.sh ### User define Function (UDF) ### sql_bak () { echo &quot;Running mysqldump tool...&quot;; } sync_bak () { echo &quot;Running rsync tool...&quot;; } git_bak () { echo &quot;Running gistore tool...&quot;; } tar_bak () { echo &quot;Running tar tool...&quot;; } </code></pre><pre><code class="bash">#!/bin/bash source /root/bin/function-2.sh ### Main script starts here ### PS3=&quot;Please choose a backup tools : &quot; select s in mysqldump rsync gistore tar quit ; do    case $REPLY in         1|[mM]ysqldump) sql_bak  ;;         2|[rR]sync)     sync_bak ;;         3|[gG]istore)   git_bak  ;;         4|[tT]ar)       tar_bak  ;;         5) exit     ;;     esac done</code></pre><h1 id="5-参数与变量"><a href="#5-参数与变量" class="headerlink" title="5. 参数与变量"></a>5. 参数与变量</h1><p><strong>1. 参数</strong></p><ul><li>调用函数时，使用位置参数的形式为函数传递参数 </li><li>函数内的$1-${n}、$*和$@表示接收到的参数<ul><li>$1-${n}表示第n个参数</li><li>$*表示将所有位置参量看成一个字符串</li><li>$@表示将每个位置参量看成单独的字符串（以空格间隔） </li></ul></li><li>函数调用结束后位置参数$1-${n}、 $* 和 $@ 将被重置为调用函数之前的值 </li><li>在主程序和函数中，$0始终代表脚本名</li></ul><p><strong>2. 变量</strong></p><ul><li><p>函数内使用 local 声明的变量是局部变量 </p><p>局部变量的作用域是当前函数以及其调用的所有函数 </p></li><li><p>函数内未使用 local 声明的变量是全局变量 </p><p>主程序和函数中的同名变量是一个变量（地址一致）</p></li></ul><h1 id="6-函数的结束和返回值"><a href="#6-函数的结束和返回值" class="headerlink" title="6. 函数的结束和返回值"></a>6. 函数的结束和返回值</h1><ul><li><strong>当函数的最后一条命令执行结束，函数结束</strong><ul><li>函数的返回值就是最后一条命令的退出码</li><li>其返回值被保存在系统变量<code>$?</code>中</li></ul></li><li><strong>可以使用return 或exit显示地结束函数</strong><ul><li><code>return [N]</code><ul><li><code>return</code>将结束函数的执行<ul><li>可以使用N指定返回值</li></ul></li></ul></li><li><code>exit [N]</code><ul><li><code>exit</code>将中断当前函数和当前Shell的执行<ul><li>可以使用N指定返回值</li></ul></li></ul></li></ul></li></ul><p><strong>return只能返回整数值</strong>，可以使用标准输出实现函数的返回值</p><ul><li><strong>标准输出实现函数的返回值</strong><ul><li>通用的方法，既能返回整数又能返回字符串</li><li>函数结束前使用 <code>echo</code> 命令将结果显示到标准输出 </li><li>调用函数时使用如下的格式将函数的输出结果存到变量<code>RES</code>中，之后便可使用变量<code>$RES</code>的值</li></ul></li></ul><h1 id="7-标准输出实现函数的返回值举例"><a href="#7-标准输出实现函数的返回值举例" class="headerlink" title="7. 标准输出实现函数的返回值举例"></a>7. 标准输出实现函数的返回值举例</h1><pre><code class="bash">#!/bin/bash # User define Function (UDF) to_upper () {     local str=&quot;$@&quot;     local output     output=$(tr &#39;[a-z]&#39; &#39;[A-Z]&#39;&lt;&lt;&lt;&quot;${str}&quot;)     echo $output } ### Main script starts here ### to_upper &quot;This Is a TEST&quot; res=$(to_upper &quot;$@&quot;) echo &quot;$res&quot; res=$(to_upper &quot;$1&quot;) [[ $res == &quot;YES&quot; ]] &amp;&amp; echo &quot;Continue...&quot; || echo &quot;Stop&quot; </code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>白嫖系列——WebStorm</title>
      <link href="/2020/05/16/%E7%99%BD%E5%AB%96%E7%B3%BB%E5%88%97_WebStorm/"/>
      <url>/2020/05/16/%E7%99%BD%E5%AB%96%E7%B3%BB%E5%88%97_WebStorm/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><blockquote><p>仅供学习交流使用，请支持正版，谢谢合作（白嫖，它不香么？）</p></blockquote><h1 id="1-下载软件"><a href="#1-下载软件" class="headerlink" title="1. 下载软件"></a>1. 下载软件</h1><p>官方下载地址：<a href="https://www.jetbrains.com/webstorm/download/" target="_blank" rel="noopener">https://www.jetbrains.com/webstorm/download/</a></p><p>百度网盘下载链接：<a href="https://pan.baidu.com/s/19h9uKAeJJJ08-n4K-5misg" target="_blank" rel="noopener">https://pan.baidu.com/s/19h9uKAeJJJ08-n4K-5misg</a><br>提取码：<code>4x6n</code></p><h1 id="2-下载白嫖包"><a href="#2-下载白嫖包" class="headerlink" title="2. 下载白嫖包"></a>2. 下载白嫖包</h1><p>百度网盘下载链接：<a href="https://pan.baidu.com/s/1iLCAYK1-k0js8Mjc3Lb2RA" target="_blank" rel="noopener">https://pan.baidu.com/s/1iLCAYK1-k0js8Mjc3Lb2RA</a><br>提取码：<code>mmx9</code></p><h1 id="3-引入包"><a href="#3-引入包" class="headerlink" title="3. 引入包"></a>3. 引入包</h1><ol><li>鼠标右键点击WebStorm的图标，点击<code>打开文件所在位置</code>，将这三个文件复制到安装目录下。</li></ol><p><img src="/img/article_img/%E7%99%BD%E5%AB%96%E7%B3%BB%E5%88%97/WebStorm1.png#pic_center" alt="破解文件"></p><ol start="2"><li>鼠标右键点击<code>地址栏</code>，点击<code>复制地址</code>，我这里的地址为：</li></ol><pre><code class="bash">D:\Program Files\JetBrains\WebStorm 2018.2.3\bin</code></pre><ol start="3"><li>用记事本打开<code>webstorm.exe.vmoptions</code>文件，把最后一行改成：</li></ol><pre><code class="bash">-javaagent:刚刚复制的地址\JetbrainsCrack.jar</code></pre><ol start="4"><li>以同样的方式修改<code>webstorm64.exe.vmoptions</code> 文件。</li></ol><h1 id="4-输入激活码"><a href="#4-输入激活码" class="headerlink" title="4. 输入激活码"></a>4. 输入激活码</h1><ol><li>打开我分享的<code>激活码.txt</code>，<code>Ctrl+A</code>全选，<code>Ctrl+C</code>复制</li></ol><p><img src="/img/article_img/%E7%99%BD%E5%AB%96%E7%B3%BB%E5%88%97/WebStorm2.png#pic_center" alt="激活码"></p><ol start="2"><li>打开WebStorm，输入激活码。激活完成！</li></ol>]]></content>
      
      
      <categories>
          
          <category> 白嫖系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 白嫖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora基础教程——快捷键篇</title>
      <link href="/2020/05/16/Typora_%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2020/05/16/Typora_%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="1-视图操作快捷"><a href="#1-视图操作快捷" class="headerlink" title="1. 视图操作快捷"></a>1. 视图操作快捷</h1><table><thead><tr><th align="center">功能</th><th align="center">快捷键</th></tr></thead><tbody><tr><td align="center">大纲视图</td><td align="center">Ctrl+Shift+1</td></tr><tr><td align="center">文件列表视图</td><td align="center">Ctrl+Shift+2</td></tr><tr><td align="center">放大视图</td><td align="center">Ctrl+Shift+‘+’</td></tr><tr><td align="center">缩小视图</td><td align="center">Ctrl+Shift+‘-’</td></tr><tr><td align="center">源代码模式</td><td align="center">Ctrl+/</td></tr><tr><td align="center">专注模式(当前编辑行为黑，其他行为灰色)</td><td align="center">F8</td></tr><tr><td align="center">打字机模式(光标始终在屏幕中央位置)</td><td align="center">F9</td></tr></tbody></table><h1 id="2-标题段落快捷键"><a href="#2-标题段落快捷键" class="headerlink" title="2. 标题段落快捷键"></a>2. 标题段落快捷键</h1><p><code>MarkDown</code>支持6级标题，可以使用<code>Ctrl+数字</code> 指定不同层次的标题和段落</p><table><thead><tr><th align="center">功能</th><th align="center">快捷键</th></tr></thead><tbody><tr><td align="center">正文</td><td align="center">Ctrl + 0</td></tr><tr><td align="center">1级标题</td><td align="center">Ctrl + 1</td></tr><tr><td align="center">2级标题</td><td align="center">Ctrl + 2</td></tr><tr><td align="center">k级标题</td><td align="center">Ctrl + k</td></tr><tr><td align="center">6级标题</td><td align="center">Ctrl + 6</td></tr><tr><td align="center">提升标题级别</td><td align="center">Ctrl + ‘+’</td></tr><tr><td align="center">降低标题级别</td><td align="center">Ctrl + ‘-</td></tr></tbody></table><h1 id="3-字体操作快捷键"><a href="#3-字体操作快捷键" class="headerlink" title="3. 字体操作快捷键"></a>3. 字体操作快捷键</h1><table><thead><tr><th align="center">功能</th><th align="center">快捷键</th></tr></thead><tbody><tr><td align="center">字体加粗</td><td align="center">Ctrl + B</td></tr><tr><td align="center">下划线</td><td align="center">Ctrl + U</td></tr><tr><td align="center">倾斜</td><td align="center">Ctrl + I</td></tr><tr><td align="center">删除线</td><td align="center">Alt + Shift + 5</td></tr></tbody></table><h1 id="4-插入功能快捷键"><a href="#4-插入功能快捷键" class="headerlink" title="4. 插入功能快捷键"></a>4. 插入功能快捷键</h1><table><thead><tr><th align="center">功能</th><th align="center">快捷键</th></tr></thead><tbody><tr><td align="center">插入图片</td><td align="center">Ctrl+Shift+I</td></tr><tr><td align="center">插入表格</td><td align="center">Ctrl+T</td></tr><tr><td align="center">插入有序列表</td><td align="center">Ctrl+Shift+[</td></tr><tr><td align="center">插入无序列表</td><td align="center">Ctrl+Shift+]</td></tr><tr><td align="center">插入超链接</td><td align="center">Ctrl+K</td></tr><tr><td align="center">插入代码片</td><td align="center">Ctrl+Shift+`</td></tr><tr><td align="center">插入代码块</td><td align="center">Ctrl+Shift+K</td></tr><tr><td align="center">插入公式块</td><td align="center">Ctrl+Shift+M</td></tr><tr><td align="center">插入引用块</td><td align="center">Ctrl+Shift+Q</td></tr></tbody></table><h1 id="5-表格扩展快捷键"><a href="#5-表格扩展快捷键" class="headerlink" title="5. 表格扩展快捷键"></a>5. 表格扩展快捷键</h1><table><thead><tr><th align="center">功能</th><th align="center">快捷键</th></tr></thead><tbody><tr><td align="center">下方插入行</td><td align="center">Ctrl+Enter（回车）</td></tr><tr><td align="center">删除该行</td><td align="center">Shift+Ctrl+BackSpace（退格）</td></tr><tr><td align="center">上移该行</td><td align="center">Shift+Ctrl+↑</td></tr><tr><td align="center">下移该行</td><td align="center">Shift+Ctrl+↓</td></tr><tr><td align="center">左移该列</td><td align="center">Shift+Ctrl+←</td></tr><tr><td align="center">右移该列</td><td align="center">Shift+Ctrl+→</td></tr></tbody></table><h1 id="6-跳转操作"><a href="#6-跳转操作" class="headerlink" title="6. 跳转操作"></a>6. 跳转操作</h1><table><thead><tr><th align="center">功能</th><th align="center">快捷键</th></tr></thead><tbody><tr><td align="center">跳转到文首</td><td align="center">Ctrl+Home<br />Ctrl+Fn+←</td></tr><tr><td align="center">跳转到所选内容</td><td align="center">Ctrl+J</td></tr><tr><td align="center">跳转到文末</td><td align="center">Ctrl+End<br />Ctrl+Fn+→</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Typora </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7 添加一个简单的系统调用（内核模块法）</title>
      <link href="/2020/04/23/Linux_CentOS7%E6%B7%BB%E5%8A%A0%E7%AE%80%E5%8D%95%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8_%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E6%B3%95/"/>
      <url>/2020/04/23/Linux_CentOS7%E6%B7%BB%E5%8A%A0%E7%AE%80%E5%8D%95%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8_%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><blockquote><ol><li>学习Linux的内核的系统调用。</li><li>理解、掌握Linux系统调用的实现框架、用户界面、参数传递、进入/返回过程。</li></ol></blockquote><h1 id="二、实验内容"><a href="#二、实验内容" class="headerlink" title="二、实验内容"></a>二、实验内容</h1><blockquote><p>在系统调用中添加一个不用传递参数的系统调用，实现一个简单的系统调用的添加。执行这个系统调用，在屏幕上显示输出“Hello World! ”。</p></blockquote><h1 id="三、实验环境"><a href="#三、实验环境" class="headerlink" title="三、实验环境"></a>三、实验环境</h1><blockquote><p>虚拟机软件：Vmware Workstation<br>Linux发行版：CentOS 7  内置内核：linux 3.10.0<br>待编译内核：linux 4.15.10</p></blockquote><h1 id="四、操作方法和步骤"><a href="#四、操作方法和步骤" class="headerlink" title="四、操作方法和步骤"></a>四、操作方法和步骤</h1><h2 id="（1）准备工作"><a href="#（1）准备工作" class="headerlink" title="（1）准备工作"></a>（1）准备工作</h2><ol><li>查询syscall_table的地址，执行命令：</li></ol><pre><code class="bash">sudo cat /proc/kallsyms | grep sys_call_table</code></pre><p><img src="/img/article_img/Linux/CentOS7%E6%B7%BB%E5%8A%A0%E7%AE%80%E5%8D%95%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8_%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E6%B3%951.png#pic_center" alt="查询syscall_table地址"></p><ol start="2"><li>查询可用的系统调用号，使用vim编辑器打开unistd_32.h，执行命令：</li></ol><pre><code class="bash">vim /usr/include/asm/unistd_32.h</code></pre><p>在普通模式下，输入<code>G</code>或者<code>shift+g</code>定位到文尾，可以看到最后一个是383，因此384是可用的系统调用号</p><p><img src="/img/article_img/Linux/CentOS7%E6%B7%BB%E5%8A%A0%E7%AE%80%E5%8D%95%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8_%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E6%B3%952.png#pic_center" alt="查询可用的系统调用号"></p><h2 id="（2）创建hello-c文件"><a href="#（2）创建hello-c文件" class="headerlink" title="（2）创建hello.c文件"></a>（2）创建hello.c文件</h2><ul><li>sys_call_table为上面查询到的系统调用表的地址，NUM为待添加的系统调用号</li><li>使用<code>vim</code>命令创建<code>hello.c</code>，并添加以下内容：</li></ul><pre><code class="bash">#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/unistd.h&gt;#include &lt;linux/sched.h&gt;MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);#define SYS_CALL_TABLE_ADDRESS 0xffffffffa8400160  //sys_call_table对应的地址#define NUM 384  //系统调用号为384int orig_cr0;  //用来存储cr0寄存器原来的值unsigned long *sys_call_table_my=0;static int(*anything_saved)(void);  //定义一个函数指针，用来保存一个系统调用static int clear_cr0(void) //使cr0寄存器的第17位设置为0（内核空间可写）{    unsigned int cr0=0;    unsigned int ret;    asm volatile(&quot;movq %%cr0,%%rax&quot;:&quot;=a&quot;(cr0));//将cr0寄存器的值移动到eax寄存器中，同时输出到cr0变量中    ret=cr0;    cr0&amp;=0xfffffffffffeffff;//将cr0变量值中的第17位清0,将修改后的值写入cr0寄存器    asm volatile(&quot;movq %%rax,%%cr0&quot;::&quot;a&quot;(cr0));//将cr0变量的值作为输入，输入到寄存器eax中，同时移动到寄存器cr0中    return ret;}static void setback_cr0(int val) //使cr0寄存器设置为内核不可写{    asm volatile(&quot;movq %%rax,%%cr0&quot;::&quot;a&quot;(val));}asmlinkage long sys_mycall(void) //定义自己的系统调用{       printk(&quot;模块系统调用-当前pid：%d，当前comm:%s\n&quot;,current-&gt;pid,current-&gt;comm);    printk(&quot;hello,world!\n&quot;);    return current-&gt;pid;    }static int __init call_init(void){    sys_call_table_my=(unsigned long*)(SYS_CALL_TABLE_ADDRESS);    printk(&quot;call_init......\n&quot;);    anything_saved=(int(*)(void))(sys_call_table_my[NUM]);//保存系统调用表中的NUM位置上的系统调用    orig_cr0=clear_cr0();//使内核地址空间可写    sys_call_table_my[NUM]=(unsigned long) &amp;sys_mycall;//用自己的系统调用替换NUM位置上的系统调用    setback_cr0(orig_cr0);//使内核地址空间不可写    return 0;}static void __exit call_exit(void){    printk(&quot;call_exit......\n&quot;);    orig_cr0=clear_cr0();    sys_call_table_my[NUM]=(unsigned long)anything_saved;//将系统调用恢复    setback_cr0(orig_cr0);}module_init(call_init);module_exit(call_exit);</code></pre><h2 id="（3）创建Makefile文件"><a href="#（3）创建Makefile文件" class="headerlink" title="（3）创建Makefile文件"></a>（3）创建Makefile文件</h2><ul><li>使用<code>vim</code>命令创建Makefile文件，添加以下内容</li></ul><pre><code class="bash">obj-m:=hello.oCURRENT_PATH:=$(shell pwd)LINUX_KERNEL_PATH:=/usr/src/linux-4.15.10all:    make -C  $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modulesclean:    make -C  $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean</code></pre><ul><li><strong>注意：</strong><code>LINUX_KERNEL_PATH</code>是内核代码的位置</li></ul><h2 id="（4）安装内核模块"><a href="#（4）安装内核模块" class="headerlink" title="（4）安装内核模块"></a>（4）安装内核模块</h2><ol><li>执行命令:</li></ol><pre><code class="c">make</code></pre><ol start="2"><li>查看make是否成功，执行命令：</li></ol><pre><code class="bash">ls | grep &#39;hello.*&#39;</code></pre><p>看到有<code>ko</code>，<code>mod.c</code>，<code>mod.o</code>文件就说明成功了</p><ol start="3"><li>使用insmod插入模块，执行命令：</li></ol><pre><code class="bash">insmod hello.ko</code></pre><ol start="4"><li>使用lsmod查看模块是否插入成功，执行命令：</li></ol><pre><code class="bash">lsmod</code></pre><p><code>Module</code>出现hello，表示模块插入成功</p><h2 id="（5）测试系统调用"><a href="#（5）测试系统调用" class="headerlink" title="（5）测试系统调用"></a>（5）测试系统调用</h2><ol><li>使用vim创建test.c文件，执行命令：</li></ol><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;linux/kernel.h&gt;#include&lt;sys/syscall.h&gt;#include&lt;unistd.h&gt;int main(){        unsigned long x = 0;        x = syscall(483);        //测试483号系统调用        printf(&quot;17计科-1727405169 syscall result: %ld\n&quot;, x);        return 0;}</code></pre><ol start="2"><li>使用gcc编译，执行命令：</li></ol><pre><code class="c">gcc test.c</code></pre><ol start="3"><li>运行a.out，执行命令：</li></ol><pre><code class="c">./a.out</code></pre><p>出现以下结果就成功了。<br><img src="/img/article_img/Linux/CentOS7%E6%B7%BB%E5%8A%A0%E7%AE%80%E5%8D%95%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8_%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E6%B3%953.png#pic_center" alt="成功运行"></p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><ul><li>两个字高度概括，<strong>简单！</strong></li><li>剩下的你们自己慢慢写吧，有问题欢迎在留言区交流，谢谢观看。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GithubPages入门教程</title>
      <link href="/2020/04/15/Hexo_GithubPages%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2020/04/15/Hexo_GithubPages%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><hr><h1 id="一、什么是-GitHub-Pages"><a href="#一、什么是-GitHub-Pages" class="headerlink" title="一、什么是 GitHub Pages"></a>一、什么是 GitHub Pages</h1><p>​    官方给出的说明：您和您的项目的网站，直接从您的GitHub存储库托管。只需编辑，推送，您的更改就会生效。</p><hr><h1 id="二、为什么使用Github-Pages"><a href="#二、为什么使用Github-Pages" class="headerlink" title="二、为什么使用Github Pages"></a>二、为什么使用Github Pages</h1><ul><li>搭建简单而且免费</li><li>支持静态脚本</li><li>可以绑定你的域名</li><li>DIY自由发挥，动手实践一些有意思的东西</li><li>写博环境，git+github+markdown+hexo</li></ul><hr><h1 id="三、创建Github-Pages"><a href="#三、创建Github-Pages" class="headerlink" title="三、创建Github Pages"></a>三、创建Github Pages</h1><h2 id="1-创建一个GitHub账号"><a href="#1-创建一个GitHub账号" class="headerlink" title="1. 创建一个GitHub账号"></a>1. 创建一个GitHub账号</h2><ul><li><a href="https://github.com/">github官网</a></li><li>取一个适合的名字，后面会通过username .github.io访问你的主页，username是你的用户名<h2 id="2-创建一个仓库-New-repository"><a href="#2-创建一个仓库-New-repository" class="headerlink" title="2. 创建一个仓库(New repository)"></a>2. 创建一个仓库(New repository)</h2></li><li>右上角点击加号“+”，创建一个仓库<br><img src="/img/article_img/Hexo/GithubPages%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1.png#pic_center" alt="创建仓库1"></li><li>名字为username .github.io，username是你的用户名，如果不是你的用户名，它将不起作用，也就不能通过username .github.io访问你的主页<br><img src="/img/article_img/Hexo/GithubPages%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B2.png#pic_center" alt="创建仓库2"><h2 id="3-创建一个主页文件index-html"><a href="#3-创建一个主页文件index-html" class="headerlink" title="3. 创建一个主页文件index.html"></a>3. 创建一个主页文件index.html</h2></li><li>点击<code>create a new file</code>创建文件<br><img src="/img/article_img/Hexo/GithubPages%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B3.png#pic_center" alt="创建仓库1"></li><li>文件名为index.html，然后点击<code>commit new file</code>提交<br><img src="/img/article_img/Hexo/GithubPages%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B4.png#pic_center" alt="创建index.html"><br>然后就可以使用<code>username.github.io</code>访问你的主页了<h2 id="4-绑定域名"><a href="#4-绑定域名" class="headerlink" title="4. 绑定域名"></a>4. 绑定域名</h2></li><li>域名可以在阿里云、腾讯云购买，没有的也可以跳过这一步</li><li>绑定域名参考<a href="https://auligey.github.io" target="_blank" rel="noopener">Github pages 绑定个人域名</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一个Markdown文档——Hello.md</title>
      <link href="/2020/04/13/Markdown_%E7%AC%AC%E4%B8%80%E4%B8%AAMarkdown%E6%96%87%E6%A1%A3/"/>
      <url>/2020/04/13/Markdown_%E7%AC%AC%E4%B8%80%E4%B8%AAMarkdown%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><p>打开你熟悉的文本编辑器（如 <a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener">notepad++</a>），新建一个 ‘hello.md’ 文件，写入下面的内容，并保存：</p><pre><code class="c"># Hello World**This is my first time to use Markdown***第一次用文本编辑器写Markdown文档*~~这只是万里长征第一步~~ 但是，万事开头难 有了第一步，坚持下去，定有收获！</code></pre><p>‘.md’ 和 ‘.markdown’ 都是被普遍支持的扩展名，不过 ‘.md’ 更加简单和方便。</p><p>他转换成html文档后，应该是这样子：</p><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p><strong>This is my first time to use Markdown</strong><br><em>第一次用文本编辑器写Markdown文档</em><br><del>这只是万里长征第一步</del><br>但是，万事开头难 有了第一步，坚持下去，定有收获！</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Markdown</title>
      <link href="/2020/04/13/Markdown_%E5%85%B3%E4%BA%8EMarkdown/"/>
      <url>/2020/04/13/Markdown_%E5%85%B3%E4%BA%8EMarkdown/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p><a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">维基百科: Markdown</a></p><blockquote><p>Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John<br>Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者<br>HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p></blockquote><hr><h1 id="2-为什么选择-Markdown"><a href="#2-为什么选择-Markdown" class="headerlink" title="2. 为什么选择 Markdown"></a>2. 为什么选择 Markdown</h1><ul><li>它基于纯文本，方便修改和共享；</li><li>几乎可以在所有的文本编辑器中编写；</li><li>有众多编程语言的实现和应用的相关扩展；</li><li>在 GitHub 等网站中有很好的应用；</li><li>很容易转换为 HTML 文档或其他格式；</li><li>适合用来编写文档、记录笔记、撰写文章。</li></ul><hr><h1 id="3-兼容-HTML"><a href="#3-兼容-HTML" class="headerlink" title="3. 兼容 HTML"></a>3. 兼容 HTML</h1><p>Markdown 完全兼容 HTML 语法，可以直接在 Markdown 文档中插入 HTML 内容：</p><pre><code class="html">&lt;table&gt;  &lt;tr&gt;    &lt;td&gt;1行1列&lt;/td&gt;    &lt;td&gt;1行2列&lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;2行1列&lt;/td&gt;    &lt;td&gt;2行2列&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;</code></pre><p>这段代码会变成下面的样子：</p><table>  <tr>    <td>1行1列</td>    <td>1行2列</td>  </tr>  <tr>    <td>2行1列</td>    <td>2行2列</td>  </tr></table>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-hexo配置首页</title>
      <link href="/2020/04/13/Hexo_3-hexo%E9%85%8D%E7%BD%AE%E9%A6%96%E9%A1%B5/"/>
      <url>/2020/04/13/Hexo_3-hexo%E9%85%8D%E7%BD%AE%E9%A6%96%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="1-首页文件位置-layout-indexs-md"><a href="#1-首页文件位置-layout-indexs-md" class="headerlink" title="1. 首页文件位置/layout/indexs.md"></a>1. 首页文件位置/layout/indexs.md</h1><p>​    既然是md格式，大家应该都已经熟悉了，这里就不再赘述了~</p><h1 id="2-添加文章数和字数统计"><a href="#2-添加文章数和字数统计" class="headerlink" title="2. 添加文章数和字数统计"></a>2. 添加文章数和字数统计</h1><ul><li>加入含有 class=”article_number”的html标签可显示文章数量。</li><li>加入含有 class=”site_word_count”的html标签可显示站点总字数。</li></ul><pre><code class="bash">&lt;!-- 这里是借用了code的样式，所以直接使用code标签。    自定义样式，可加入style属性设置--&gt;&lt;code class=&quot;article_number&quot;&gt;&lt;/code&gt;&lt;code class=&quot;site_word_count&quot;&gt;&lt;/code&gt;</code></pre><p>​    <strong>上面代码的效果：</strong><br>​    文章共<code class="article_number"></code>篇；总字数<code class="site_word_count"></code>字；</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7 wget 正在连接 127.0.0.1:8118... 失败：拒绝连接。</title>
      <link href="/2020/04/12/Linux_wget%E6%8B%92%E7%BB%9D%E8%BF%9E%E6%8E%A5/"/>
      <url>/2020/04/12/Linux_wget%E6%8B%92%E7%BB%9D%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><p><strong>正在使用wget下载包的时候，出现了拒绝连接的错误</strong></p><pre><code class="bash">[root@CentOS7 local]# wget http://jaist.dl.sourceforge.net/project/pcre/pcre/8.33/pcre-8.33.tar.gz--2020-04-11 23:46:24--  http://jaist.dl.sourceforge.net/project/pcre/pcre/8.33/pcre-8.33.tar.gz正在连接 127.0.0.1:8118... 失败：拒绝连接。</code></pre><p><strong>查找问题的方法如下：</strong></p><h1 id="1-查看本地端口是否被占用"><a href="#1-查看本地端口是否被占用" class="headerlink" title="1. 查看本地端口是否被占用"></a>1. 查看本地端口是否被占用</h1><pre><code class="bash">[root@CentOS7 local]# netstat -ntplActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      1151/cupsd          tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1480/master         tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      1/systemd           tcp        0      0 192.168.122.1:53        0.0.0.0:*               LISTEN      1612/dnsmasq        tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1150/sshd           tcp6       0      0 ::1:631                 :::*                    LISTEN      1151/cupsd          tcp6       0      0 ::1:25                  :::*                    LISTEN      1480/master         tcp6       0      0 :::111                  :::*                    LISTEN      1/systemd           tcp6       0      0 :::22                   :::*                    LISTEN      1150/sshd           </code></pre><p>本地端口8118并没有被占用</p><h1 id="2-查看本地网络代理"><a href="#2-查看本地网络代理" class="headerlink" title="2. 查看本地网络代理"></a>2. 查看本地网络代理</h1><pre><code class="bash">[root@CentOS7 local]# export | grep -i proxydeclare -x ftp_proxy=&quot;http://127.0.0.1:8118&quot;declare -x http_proxy=&quot;http://127.0.0.1:8118&quot;declare -x https_proxy=&quot;http://127.0.0.1:8118&quot;</code></pre><p>网络http确实有代理，几乎可以断定是这个代理引发的错误。</p><p><strong>解决办法：</strong><br>尝试关闭代理，然后重新使用wget下载</p><pre><code class="bash">[root@CentOS7 local]# unset http_proxy [root@CentOS7 local]# wget http://jaist.dl.sourceforge.net/project/pcre/pcre/8.33/pcre-8.33.tar.gz--2020-04-11 23:48:38--  http://jaist.dl.sourceforge.net/project/pcre/pcre/8.33/pcre-8.33.tar.gz正在解析主机 jaist.dl.sourceforge.net (jaist.dl.sourceforge.net)... 150.65.7.130, 2001:df0:2ed:feed::feed正在连接 jaist.dl.sourceforge.net (jaist.dl.sourceforge.net)|150.65.7.130|:80... 已连接。</code></pre><p><strong>wget连接成功！</strong></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7 添加一个简单的系统调用（内核编译法）</title>
      <link href="/2020/04/07/Linux_CentOS7%E6%B7%BB%E5%8A%A0%E7%AE%80%E5%8D%95%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8_%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B3%95/"/>
      <url>/2020/04/07/Linux_CentOS7%E6%B7%BB%E5%8A%A0%E7%AE%80%E5%8D%95%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8_%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><blockquote><ol><li>学习Linux的内核的系统调用。</li><li>理解、掌握Linux系统调用的实现框架、用户界面、参数传递、进入/返回过程。</li></ol></blockquote><h1 id="二、实验内容"><a href="#二、实验内容" class="headerlink" title="二、实验内容"></a>二、实验内容</h1><blockquote><p>在系统调用中添加一个不用传递参数的系统调用，实现一个简单的系统调用的添加。执行这个系统调用，在屏幕上显示输出“Hello World! ”。</p></blockquote><h1 id="三、实验环境"><a href="#三、实验环境" class="headerlink" title="三、实验环境"></a>三、实验环境</h1><blockquote><p>虚拟机软件：Vmware Workstation<br>Linux发行版：CentOS 7  内置内核：linux 3.10.0<br>待编译内核：linux 4.15.10</p></blockquote><h1 id="四、操作方法和步骤"><a href="#四、操作方法和步骤" class="headerlink" title="四、操作方法和步骤"></a>四、操作方法和步骤</h1><h2 id="（1）下载软件包，并解压"><a href="#（1）下载软件包，并解压" class="headerlink" title="（1）下载软件包，并解压"></a>（1）下载软件包，并解压</h2><ol><li>下载地址：<a href="http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v4.x/" target="_blank" rel="noopener">http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v4.x/</a><br>可以通过<code>Ctrl+F</code>快速查找</li><li>使用<code>tar</code>命令解压文件到/usr/src目录下。执行命令：</li></ol><pre><code class="bash">tar xf ~/Downloads/linux-4.15.10.tar.gz -C /usr/src</code></pre><ol start="3"><li>解压之后，切换工作目录到<code>/usr/src/linux-4.15.10/</code>，可以是用<code>Tab</code>键补全路径。执行命令：</li></ol><pre><code class="bash">cd /usr/src/linux-4.15.10/</code></pre><ol start="4"><li>后面操作大部分都需要root权限，使用<code>su</code>命令切换用户，输入密码时不会显示。执行命令：</li></ol><pre><code class="bash">su root</code></pre><h2 id="（2）修改源程序，增加系统调用"><a href="#（2）修改源程序，增加系统调用" class="headerlink" title="（2）修改源程序，增加系统调用"></a>（2）修改源程序，增加系统调用</h2><p><strong>小提示：</strong> 在vim编辑器里，<code>i</code>字母插入，按<code>esc</code>后输入<code>:wq</code>保存并退出，<code>:q!</code>强制退出</p><ol><li>使用vim编辑<code>arch/x86/entry/syscalls/syscall_64.tbl</code>文件，添加系统调用号，在普通模式下，<code>shift+g</code>或者<code>G</code>可以直接定位到文尾。执行命令：</li></ol><pre><code class="bash">vim arch/x86/entry/syscalls/syscall_64.tbl</code></pre><p>添加两个没有使用(unuse)的系统调用号，其他格式可以参考文件中的其他系统调用，这里我添加了两个系统调用。代码如下：<br><img src="/img/article_img/Linux/CentOS7%E6%B7%BB%E5%8A%A0%E7%AE%80%E5%8D%95%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8_%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B3%951.png#pic_center" alt="添加系统调用号"></p><p>2.使用vim编辑<code>include/linux/syscalls.h</code>文件，添加原型声明。执行命令：</p><pre><code class="bash">vim include/linux/syscalls.h</code></pre><p>不传递参数的时候，void也不能漏写。代码如下：<br><img src="/img/article_img/Linux/CentOS7%E6%B7%BB%E5%8A%A0%E7%AE%80%E5%8D%95%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8_%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B3%952.png#pic_center" alt="添加原型声明"></p><ol start="3"><li>使用vim编辑<code>kernel/sys.c</code>文件，实现具体的系统调用。执行命令：</li></ol><pre><code class="bash">vim kernel/sys.c</code></pre><p>代码打一遍印象深刻一些，GoGoGo！代码如下：<br><img src="/img/article_img/Linux/CentOS7%E6%B7%BB%E5%8A%A0%E7%AE%80%E5%8D%95%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8_%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B3%953.png#pic_center" alt="系统调用的实现"></p><h2 id="（3）编译内核"><a href="#（3）编译内核" class="headerlink" title="（3）编译内核"></a>（3）编译内核</h2><p>这里就不详细说明了，请参考<a href="https://auligey.github.io/2020/04/05/CentOS7%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8/" target="_blank" rel="noopener">Linux发行版 CentOS编译内核</a></p><h2 id="（4）测试系统调用"><a href="#（4）测试系统调用" class="headerlink" title="（4）测试系统调用"></a>（4）测试系统调用</h2><ol><li>使用vim命令创建测试文件<code>mysyscall.c</code>和<code>mycall.c</code>，下面以mysyscall.c的创建和测试为例。执行命令：</li></ol><pre><code class="bash">vim mysyscall.c</code></pre><p><img src="/img/article_img/Linux/CentOS7%E6%B7%BB%E5%8A%A0%E7%AE%80%E5%8D%95%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8_%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B3%954.png#pic_center" alt="测试mysyscall"></p><ol start="2"><li>使用gcc编译c程序文件<br><em>编译的四个阶段</em></li></ol><ul><li>-E：仅执行编译预处理</li><li>-c：仅执行编译操作，不进行连接操作</li><li>-S：将C代码转换为汇编代码</li><li>-o：指定生成的输出文件</li></ul><p>直接使用<code>gcc -o</code>生成指定输出文件。执行命令：</p><pre><code class="bash">gcc -o mysyscall_test mysyscall_test.c   #使用gcc编译</code></pre><p>运行可执行文件，执行命令：</p><pre><code class="bash">./mysyscall_test        # 运行可执行文件</code></pre><p><img src="/img/article_img/Linux/CentOS7%E6%B7%BB%E5%8A%A0%E7%AE%80%E5%8D%95%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8_%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B3%955.png#pic_center" alt="gcc编译测试文件并执行"></p><p>使用<code>dmesg</code>查看printk的输出情况。执行命令：</p><pre><code class="bash">dmesg</code></pre><p><img src="/img/article_img/Linux/CentOS7%E6%B7%BB%E5%8A%A0%E7%AE%80%E5%8D%95%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8_%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B3%956.png#pic_center" alt="dmesg输出情况"><br>系统调用的<strong>返回值</strong>和<strong>printk的输出</strong>均符合预期，系统调用成功添加了！</p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><ul><li>两个字高度概括，<strong>简单！</strong></li><li>剩下的你们自己慢慢写吧，有问题欢迎在留言区交流，谢谢观看。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7 编译内核</title>
      <link href="/2020/04/05/Linux_CentOS7%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8/"/>
      <url>/2020/04/05/Linux_CentOS7%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><blockquote><ol><li>学习怎样重新编译Linux内核。</li><li>理解、掌握Linux标准内核和发行版本内核的区别。</li></ol></blockquote><h1 id="二、环境准备"><a href="#二、环境准备" class="headerlink" title="二、环境准备"></a>二、环境准备</h1><blockquote><p>虚拟机软件：Vmware Workstation<br>Linux发行版：CentOS 7  内置内核：linux 3.10.0<br>待编译内核：linux 4.15.10</p></blockquote><h1 id="三、操作方法和步骤"><a href="#三、操作方法和步骤" class="headerlink" title="三、操作方法和步骤"></a>三、操作方法和步骤</h1><ul><li>编译过程很多地方需要root权限，为了方便，直接切换到root，切换命令：</li></ul><pre><code class="bash">su root</code></pre><ul><li><strong>小提示</strong>：输入密码时不会显示，<code>$</code>表示一般用户，<code>#</code>表示超级管理员root，<code>Tab</code>键可以补全路径</li></ul><h2 id="（1）下载内核并解压"><a href="#（1）下载内核并解压" class="headerlink" title="（1）下载内核并解压"></a>（1）下载内核并解压</h2><ol><li>使用浏览器打开<a href="http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v4.x/" target="_blank" rel="noopener">http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v4.x/</a></li><li><code>Ctrl+F</code>查找linux-4.15.10.tar.gz，点击即可下载，我下载的位置是<code>/home/username/Downloads/linux-4.15.10.tar.gz</code></li><li>使用<code>tar</code>命令解压文件：</li></ol><pre><code class="c">tar xf ~/Downloads/linux-4.15.10.tar.gz -C /usr/src</code></pre><ol start="4"><li>解压之后，切换工作目录：</li></ol><pre><code class="bash">cd /usr/src/linux-4.15.10/</code></pre><h2 id="（2）配置项"><a href="#（2）配置项" class="headerlink" title="（2）配置项"></a>（2）配置项</h2><p>​    <strong>配置项的几种方式</strong></p><ul><li><code>make config</code>         基于文本的配置界面</li><li><code>make menuconfig</code>    基于文本菜单的配置界面</li><li><code>make xconfig</code>        基于图像窗口的配置界面</li><li><code>make oldconfig</code>        基于原来内核配置基础上修改</li></ul><p><strong>本文采用基于文本菜单的配置界面（make menuconfig）</strong></p><ul><li>使用<code>make menuconfig</code>需要<code>ncurses-devel</code>的支持</li><li>安装<code>ncurses-devel</code>命令：</li></ul><pre><code class="bash">yum install ncurses-devel</code></pre><ul><li>执行<code>make menuconfig</code>，开始选择配置项（<strong>注意终端窗口至少为19行，80列，否则报错提示</strong>）</li></ul><pre><code class="bash">make menuconfig</code></pre><ul><li>成功执行后，会出现下面的窗口：<br><img src="/img/article_img/Linux/CentOS7%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B81.png#pic_center" alt="menuconfig"></li><li>直接<strong>保存退出</strong>就可以了，它会使用 CentOS 内部的配置文件作为这次编译的配置文件</li></ul><h2 id="（3）编译内核"><a href="#（3）编译内核" class="headerlink" title="（3）编译内核"></a>（3）编译内核</h2><ul><li>编译需要<code>elfutils-libelf-devel</code> 和 <code>openssl-devel</code> 的支持，安装命令：</li></ul><pre><code class="bash">yum install elfutils-libelf-devel openssl-devel</code></pre><ul><li>使用<code>make</code>命令开始编译内核，可以使用多核线程提高编译速度：</li></ul><pre><code class="bash">make -j4</code></pre><p>​    <strong>emmm，编译时间很长(1小时左右，与电脑性能有关)，耐心等待</strong></p><h2 id="（4）安装"><a href="#（4）安装" class="headerlink" title="（4）安装"></a>（4）安装</h2><ul><li>漫长的等待之后，终于迎来了安装内核</li><li>执行 <code>make modules_install</code> 开始安装模块：</li></ul><pre><code class="bash">make modules_install</code></pre><ul><li>等待几分钟，执行<code>make install</code> 开始安装核心：</li></ul><pre><code class="bash">make install</code></pre><ul><li>顺利安装完成，重启虚拟机看看</li></ul><h2 id="（5）重启虚拟机"><a href="#（5）重启虚拟机" class="headerlink" title="（5）重启虚拟机"></a>（5）重启虚拟机</h2><ul><li>重启之后，进入grub界面，选择新编译的内核：<code>CentOS Linux （4.15.10）</code></li><li>进入桌面后，打开终端，使用<code>uname -a</code>查看内核版本：</li></ul><pre><code class="bash">uname -sr</code></pre><ul><li>实验做完了，才算完成了一半，<strong>还有实验报告没写！haha</strong></li></ul><hr><h1 id="四、欠揍式总结（👊警告）"><a href="#四、欠揍式总结（👊警告）" class="headerlink" title="四、欠揍式总结（👊警告）"></a>四、欠揍式总结（👊警告）</h1><ul><li><strong>有啥总结的！不是一番风顺吗？</strong></li><li><strong>Go！ 篮球场约起！</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> 操作系统课程实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-hexo快捷键说明</title>
      <link href="/2020/04/05/Hexo_3-hexo%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AF%B4%E6%98%8E/"/>
      <url>/2020/04/05/Hexo_3-hexo%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="1-说明"><a href="#1-说明" class="headerlink" title="1. 说明"></a>1. 说明</h1><blockquote><p>快捷键为vim风格的，按键可能与vimium（chrome插件）的快捷键有冲突，插件设置屏蔽掉此站的快捷键即可。</p></blockquote><h1 id="2-搜索框"><a href="#2-搜索框" class="headerlink" title="2. 搜索框"></a>2. 搜索框</h1><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>Esc</td><td>1.如果输入框有内容，清除内容 <br />2.如果输入框无内容，失去焦点（普通模式）</td></tr><tr><td>i/I</td><td>获取焦点（插入模式）</td></tr><tr><td>↑</td><td>向下选择文章</td></tr><tr><td>↓</td><td>向上选择文章</td></tr><tr><td>Enter（回车）</td><td>打开当前鼠标选中的文章<br />若没有，则默认打开第一个</td></tr></tbody></table><h1 id="3-全局"><a href="#3-全局" class="headerlink" title="3. 全局"></a>3. 全局</h1><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>s/S</td><td>全屏/取消全屏</td></tr><tr><td>w/W</td><td>打开/关闭文章目录</td></tr><tr><td>j/J</td><td>向下滑动</td></tr><tr><td>k/K</td><td>向上滑动</td></tr><tr><td>gg/GG</td><td>到最顶端</td></tr><tr><td>shift+G/g</td><td>到最下端</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo安装教程</title>
      <link href="/2020/04/04/Hexo_hexo%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2020/04/04/Hexo_hexo%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><hr><h1 id="1-安装前提"><a href="#1-安装前提" class="headerlink" title="1. 安装前提"></a>1. 安装前提</h1><p>​    安装hexo之前，需要安装下列应用程序：</p><ul><li><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a></li><li><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ul><hr><h2 id="1-1-安装-Git"><a href="#1-1-安装-Git" class="headerlink" title="1.1 安装 Git"></a>1.1 安装 Git</h2><ul><li>Windows：下载并安装 <a href="http://git-scm.com/" target="_blank" rel="noopener">Git(官网)</a>或者<a href="https://npm.taobao.org/mirrors/git-for-windows/" target="_blank" rel="noopener">淘宝 Git for Windows 镜像</a>，安装选项全部默认，在最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>，这样我们就可以直接在命令提示符里打开Git了</li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/" target="_blank" rel="noopener">Homebrew</a>, <a href="http://mxcl.github.com/homebrew/" target="_blank" rel="noopener">MacPorts</a> 或者下载<a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">安装程序</a>。</li><li>Linux (Ubuntu, Debian)：<pre><code class="c">sudo apt-get install git-core</code></pre></li><li>Linux (Fedora, Red Hat, CentOS)：<pre><code class="c">sudo yum install git-core</code></pre>​    安装完成后，在bash中输入<code>git --version</code>验证是否安装成功。</li></ul><hr><h2 id="1-2-安装-Node-js"><a href="#1-2-安装-Node-js" class="headerlink" title="1.2 安装 Node.js"></a>1.2 安装 Node.js</h2><ul><li>Node.js 为大多数平台提供了官方的<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">安装程序</a>。对于中国大陆地区用户，可以前往<a href="https://npm.taobao.org/mirrors/node" target="_blank" rel="noopener">淘宝 Node.js 镜像</a>下载。</li><li>安装完成后，在bash中输入<code>node -v</code>验证是否安装成功。</li></ul><hr><h1 id="2-安装-Hexo"><a href="#2-安装-Hexo" class="headerlink" title="2. 安装 Hexo"></a>2. 安装 Hexo</h1><ul><li>安装必备应用程序后，即可使用<code>npm</code>（你配吗hahaha开个玩笑）来安装hexo<pre><code class="bash">$ npm install -g hexo-cli</code></pre></li></ul><hr><h1 id="3-使用-hexo"><a href="#3-使用-hexo" class="headerlink" title="3. 使用 hexo"></a>3. 使用 hexo</h1><p>​    安装后，可以使用两种方式执行hexo（推荐使用第二种哦:dog:~~~）：</p><ul><li><p><code>npx hexo &lt;命令&gt;</code></p></li><li><p>将 <strong>hexo 所在的目录下</strong>的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo &lt;命令&gt;</code>：</p><pre><code class="bash">echo &#39;PATH=&quot;$PATH:./node_modules/.bin&quot;&#39; &gt;&gt; ~/.profile</code></pre><p><strong>hexo走起！</strong></p></li></ul><h1 id="4-使用hexo搭建博客"><a href="#4-使用hexo搭建博客" class="headerlink" title="4. 使用hexo搭建博客"></a>4. 使用hexo搭建博客</h1><p>​    推荐参考文章：<a href="/2020/07/17/Hexo_hexo搭建个人博客/">hexo搭建个人博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>白嫖系列——xmind 8</title>
      <link href="/2020/04/04/%E7%99%BD%E5%AB%96%E7%B3%BB%E5%88%97_Xmind8/"/>
      <url>/2020/04/04/%E7%99%BD%E5%AB%96%E7%B3%BB%E5%88%97_Xmind8/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><blockquote><p>仅供学习交流使用，请支持正版，谢谢合作（白嫖，它不香么？）</p></blockquote><h1 id="1-在官网下载xmind最新的版本，安装软件"><a href="#1-在官网下载xmind最新的版本，安装软件" class="headerlink" title="1.在官网下载xmind最新的版本，安装软件"></a>1.在官网下载xmind最新的版本，安装软件</h1><p>​    官网地址：<a href="https://www.xmind.cn/download/xmind8" target="_blank" rel="noopener">https://www.xmind.cn/download/xmind8</a><br>​    本文用的是XMind 8 Update 9</p><h1 id="2-下载软件包"><a href="#2-下载软件包" class="headerlink" title="2.下载软件包"></a>2.下载软件包</h1><p>​    链接：<a href="https://pan.baidu.com/s/1TdcEU6RYYvAmpoMkpBj8MA" target="_blank" rel="noopener">https://pan.baidu.com/s/1TdcEU6RYYvAmpoMkpBj8MA</a><br>​    提取码：<code>3nbc</code> </p><h1 id="3-找到安装目录"><a href="#3-找到安装目录" class="headerlink" title="3. 找到安装目录"></a>3. 找到安装目录</h1><p>​    本文的是：<code>D:\Program Files (x86)\XMind</code><br>​    如果找不到，可以通过鼠标右键xmind图标–&gt;打开文件所在位置<br><img src="/img/article_img/%E7%99%BD%E5%AB%96%E7%B3%BB%E5%88%97/Xmind1.png#pic_center" alt="查找xmind安装位置"></p><h1 id="4-打开我分享的文件"><a href="#4-打开我分享的文件" class="headerlink" title="4.打开我分享的文件"></a>4.打开我分享的文件</h1><p><img src="/img/article_img/%E7%99%BD%E5%AB%96%E7%B3%BB%E5%88%97/Xmind2.png#pic_center" alt="查找xmind破解文件"><br>​    找到这个<code>.jar</code>的文件，复制到xmind的安装目录（第3步中的安装路径）</p><h1 id="5-修改xmind配置文件-xmind-ini"><a href="#5-修改xmind配置文件-xmind-ini" class="headerlink" title="5.修改xmind配置文件(xmind.ini)"></a>5.修改xmind配置文件(xmind.ini)</h1><p>​    在安装目录下，找到xmind.ini文件，用记事本打开<br>​    在最后<strong>添加一句代码</strong></p><pre><code class="bash">-javaagent:D:\Program Files(x86)\XMind\XMindCrack.jar</code></pre><p>​    并<strong>保存文件</strong><br>​    <strong>注意：</strong> <code>-javaagent:</code>后面为<code>XMindCrack.jar</code>文件的路径，<strong>冒号要使用英文</strong></p><h1 id="6-打开安装后的xmind"><a href="#6-打开安装后的xmind" class="headerlink" title="6.打开安装后的xmind"></a>6.打开安装后的xmind</h1><ul><li><p>在<strong>菜单栏</strong>找到 “帮助” –&gt; “序列号”，填写<strong>邮箱</strong>和<strong>序列号</strong></p></li><li><p>邮箱随便填写一个正确的格式，也可以填写你自己的邮箱</p></li><li><p>打开我分享的文件<code>xmind激活序列号.txt</code>，复制粘贴上去<br><img src="/img/article_img/%E7%99%BD%E5%AB%96%E7%B3%BB%E5%88%97/Xmind3.png#pic_center" alt="获取xmind激活序列号"></p><p><strong>激活成功<br>放肆的使用吧！</strong></p></li></ul><p><strong>PS：</strong>仅供学习交流使用，任何人不得以商业盈利为目的，否则一切责任自己承担！</p>]]></content>
      
      
      <categories>
          
          <category> 白嫖系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 白嫖 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
